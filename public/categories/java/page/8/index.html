<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Java | 分享技术带来的喜悦</title>
<meta name="keywords" content="">
<meta name="description" content="技术分享博客">
<meta name="author" content="Bridge Li">
<link rel="canonical" href="http://localhost:1313/categories/java/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css" integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/categories/java/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/categories/java/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="分享技术带来的喜悦 (Alt + H)">分享技术带来的喜悦</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/categories/">Categories</a></div>
  <h1>
    Java
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Blowfish加密算法Java版简单实现
    </h2>
  </header>
  <div class="entry-content">
    <p>前几天网上突然出现流言：某东发生数据泄露12G，最终某东在一篇声明中没有否认，还算是勉强承认了吧，这件事对于一般人有什么影响、应该怎么做已经有一堆人说了，所以就不凑热闹了，咱来点对程序猿来说实际点的，说一个个人认为目前比较安全的加密算法：Blowfish。
上代码之前，先说几点Blowfish加密算法的特点：
对称加密，即加密的密钥和解密的密钥是相同的； 每次加密之后的结果是不同的（这也是老夫比较欣赏的一点）； 可逆的，和老夫之前的文章介绍的md5等摘要算法不一样，他是可逆的； 速度快，加密和解密的过程基本上由ADD和XOR指令运算组成； 免费，任何人都可以免费使用不需要缴纳版权费； BlowFish 每次只能加密和解密8字节数据； 接下来就是最重要的部分，Blowfish加密算法的实现：
package cn.bridgeli.encrypt; public enum BlowfishManager { BRIDGELI_CN(&#34;bridgeli_cn!@#$abc123_&#34;); private BlowfishManager(String secret) { this.blowfish = new Blowfish(secret); } private Blowfish blowfish; public Blowfish getBlowfish() { return blowfish; } /** * 解密 * @param sCipherText * @return */ public String decryptString(String sCipherText){ return this.getBlowfish().decryptString(sCipherText); } /** * 加密 * @param sPlainText * @return */ public String encryptString(String sPlainText){ return this.getBlowfish().encryptString(sPlainText); } public static void main(String[] args) { String encryptString = BlowfishManager.BRIDGELI_CN.encryptString(10 &#43; &#34;&#34;); System.out.println(encryptString); String decryptString = BlowfishManager.BRIDGELI_CN.decryptString(encryptString); System.out.println(decryptString); } } 这是对外的接口，使用起来非常简单，对用户很友好，下面是算法的具体实现：
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-12-18 12:04:43 +0000 +0000'>December 18, 2016</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>3241 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Blowfish加密算法Java版简单实现" href="http://localhost:1313/posts/2016-12-18-blowfish%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95java%E7%89%88%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Dubbo服务telnet调试法
    </h2>
  </header>
  <div class="entry-content">
    <p>公司的RPC的服务使用的是阿里巴巴的dubbo，老夫之前曾经写过一篇如何在测试环境远程调试dubbo服务，详情请参考这篇，但一直对如何调试线上dubbo服务不得法，不得已每次都需要写一个web服务调一下看数据，前一段时间经新来的一个同事提示可以使用Telnet调试，网上搜了一下资料，发现真的很爽，以下是学习笔记。
需要说明的是：Dubbo2.0.5以上版本服务提供端口支持telnet命令，不过应该没有公司使用2.0.5以下版本吧。
进入调试模式 telnet localhost 20880 即：telnet &#43; ip &#43; 端口，这个不用解释，使用dubbo的肯定都知道
ls 使用上一个命令之后，敲一下回车，就进入dubbo的telnet调试服务了，然后就可以使用ls命令了，这个命令有几个用法：
①. 显示服务列表
ls ②. 显示服务详细信息列表
ls -l ③. 显示服务的方法列表
ls XxxService ④. 显示服务的方法详细信息列表
ls -l XxxService ps 这个命令主要是看连接信息，也有如下几个用法：
①. 显示服务端口列表
ps ②. 显示服务地址列表
ps -l ③. 显示端口上的连接信息
ps 20880 ④, 显示端口上的连接详细信息
ps -l 20880 cd 这个缺省服务，主要有以下两个用法：
①. 改变缺省服务，当设置了缺省服务，凡是需要输入服务名作为参数的命令，都可以省略服务参数
cd XxxService ②. 取消缺省服务
cd / pwd 显示当前缺省服务
trace 这个命令顾名思义：跟踪，具体有以下用法：
①. 跟踪1次服务任意方法的调用情况
trace XxxService ②. 跟踪10次服务任意方法的调用情况
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-11-27 13:12:26 +0000 +0000'>November 27, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>164 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Dubbo服务telnet调试法" href="http://localhost:1313/posts/2016-11-27-dubbo%E6%9C%8D%E5%8A%A1telnet%E8%B0%83%E8%AF%95%E6%B3%95/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">VIM常用命令
    </h2>
  </header>
  <div class="entry-content">
    <p>上个周苹果公司悍然发布了新版mac，消灭了功能键，包括ESC，终于使下面这个段子成为了事实：问，如何生成一段随机数？答：让一个非开发人员退出vim。哈哈，现在开发人员是不是也可以产生随机字符串了？发现自己作为一个vim党，竟然对很多vim常用的命令都不知道，今天就记一下笔记，让自己这个vim党称呼实至名归。
首先要说明的是，基本的vim命令像A、I、O进入编辑模式，ESC进入命令模式，“:”进入末行模式，以及常用的什么dd，yy，p等都认为大家已经熟练掌握，就不说了。
替换字符 :%s/oldchar/newchar/g 这个命令同样可以解决：
注1. 在windows记事本下的文件放到Linux下时，行末多出来一个^M，这个问题，直接把oldchar换成\r，newchar传承空就可以了。
注2. 在windows记事本下的文件放到Linux下时，行末多出来一个^@，这个问题，直接把oldchar换成先摁ctrl&#43;v，然后摁ctrl&#43;2，newchar传承空就可以了。
注3. 在windows记事本下的文件放到Linux下时，行末多出来一个^A，这个问题，直接把oldchar换成先摁ctrl&#43;v，然后摁ctrl&#43;A，newchar传承空就可以了。
注4. oldchar也可以用正则表达式，之前一直不知道怎么在每一行的行末加东西，其实如此简单而已。
加密文件 进入末行模式，然后输入大写的X，然后输入密码，保存退出即可，这样的话今后每次打开都需要输入密码才行，否则就是一堆乱码。
undo和redo 这个比较简单，undo直接摁u，redo是ctrl&#43;r
简单的移动光标 0 数字零，到行头 ^ 到本行第一个不是blank字符的位置 $ 到本行行尾 g_ 到本行最后一个不是blank字符的位置 /pattern 搜索 pattern 的字符串,如果搜索出多个匹配，可按n键到下一个 . (小数点) 可以重复上一次的命令 N&lt;command&gt; 重复某个命令N次 :N 到第N行 gg 到第一行。（陈皓注：相当于1G，或 :1） G 到最后一行 块操作: ctrl-v 块操作，典型的操作： 0、ctrl-v、ctrl-d、I、ESC
^ 到行头 ctrl-v 开始块操作 ctrl-d 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I 插入，然后输入 ESC 来为每一行生效。 自动提示 在输入模式下，你可以输入一个词的开头，然后按 ctrl-p或是ctrl-n，自动补齐功能就出现了
可视化选择： v,V,ctrl-v ctrl-v，我们可以使用 v 和 V。一但被选好了，你可以做下面的事： J 把所有的行连接起来（变成一行） &lt; 或 &gt; 左右缩进 = 自动给缩进 窗口分屏浏览 :He 在下边分屏浏览目录 :He! 在上分屏浏览目录 :Ve 在左边分屏间浏览目录 :Ve! 要在右边则是 多页签（tab page） 在末行模式下，输入：
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-11-06 13:05:15 +0000 +0000'>November 6, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>144 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to VIM常用命令" href="http://localhost:1313/posts/2016-11-06-vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">我看拉勾一拍之系统架构
    </h2>
  </header>
  <div class="entry-content">
    <p>今年年中的时候由公司平台部转组到Alpha项目中心负责公司一拍项目组的技术研发工作，到现在已经快有将近半年的时间了，随着对系统的越来越熟悉，对原有系统的架构也越来越感到有些不合理的地方，随着自己水平的提升感觉对架构也有了一点自己的理解，所以今天就借这个机会说说自己的不成熟的建议。
一. 原有的架构
俗话说，一图胜千言，直接上图：
解释一下这几个系统分别的作用：
后台管理系统不用说了，管理C和B可见的内容； C端用户系统，是对C可见的一个系统，一拍是一个招聘系统，所以就是对候选人操作的后台； B端用户系统，是对B可见的一个系统，通俗点讲就是HR操作的后台； Dubbo系统，是对兄弟部门和B提供服务的一个系统； Recommend系统，其实也是一个Dubbo系统，区别在于Dubbo系统是对外提供各种服务的，而Recommend系统是发现全站系统用户的行为，然后对用户的行为进行分析，甄选出一部分C端用户作为一拍的现在用户； msgpush系统，是用netty做的一个实时消息推送的IM服务，目前主要是给后台管理用户和C端候选人聊天的一个系统； 其中：1. 在我们接手之前B和C是同一个系统，也就是说B是我们这半年新加的一个系统；2. Recommend和msgpush系统也同样是我们这半年新增的一个系统
二. 系统架构存在的问题
目前后台管理系统、C端用户系统、Dubbo系统各自独立，这样存在的问题：
最主要的是各自分别操作数据库，这样只要底层数据库发送变动，那么三个系统操作数据库的地方都要同步修改三次；
操作数据库的地方代码冗余，很多地方都一样，这样一个地方出bug，三个地方要同步修改，然后都要上线；
后台管理系统采用分层的模式分模块而不是根据业务分模块，这样每次上线service和dao都要先deploy jar到maven私服；
当时为了快速迭代，Recommend系统也是单独操作操作数据库，不过还好用了后台管理系统的dao这个jar包，但是首先根本不需要这么重的一个jar包，其次jar出bug了，有时候他也需要重新上线啊，不然这个jar包就会一直很旧，当然只要不涉及到他操作数据库的地方出bug，你不改也是可以的；
目前C和B虽然已经分开，但如果用户激增，横向扩展依然不合理，只能整体加机器，而不能针对性对某些模块单独加机器；
代码中存在的问题：不知道什么原因大量的逻辑被写在了controller层，导致代码可复用性差；
由于之前后台管理系统和其他系统不是同一个团队开发的，命名各有各的风格，代码不仅冗余还同样一个类名字不一样；
很多系统日志配置的也有问题，错误日志和最基本的业务日志没有区分开，目前在将就用；
系统中的jar依赖不仅存在循环依赖，而且加入了大量的自己不需要的依赖，导致各种jar冲突出问题；
综合以上问题，我个人认为这是一个：可维护性、可扩展性不高的系统。
三. 我的个人思考
同样先来一张图，来总体说明一下我的想法：
整体来说只有相对独立的实时消息推送系统不懂，然后把其余的各个业务层抽象成微服务，采用公司目前使用比较成熟的dubbo作为rpc框架，controller层只负责业务转发不负责逻辑的一个简单系统，这样带来的好处：
Dubbo系统作为核心的业务系统，分别对兄弟部门、后台管理系统、C端用户系统、B端用户系统、Recommend系统提供服务，如果用户量增加，不仅可以整体增加Dubbo系统的机器，也可以把调用量大的接口单独拆出来，部署到另外的机器上，实现隔离，不会因某个接口调用量大，导致整个系统不可用，而且把数据库的底层操作也放到了这个Dubbo系统中，这样就可以避免数据库修改，要修改多处的问题； 抽象出来的这个dubbo系统，不仅可以解决后台系统和其他系统命名不一样的问题，而且和可以解决不同团队造成的coding style不一的问题，一举多得； 由于后台管理系统、C端用户系统、B端用户系统、Recommend系统都调用Dubbo系统，所以他们的controller层讲极其简单，很多业务逻辑类似的东西全部放到了Dubbo系统里面，代码的可复用性提高了不少； 抽象出来的逻辑都统一放到了dubbo中，这样系统如果有bug，这样就做到了一个地方修改，这样多个地方就可以同时生效； 由于业务都在Dubbo系统里面这样同时也避免了曾经出现了，后台管理系统和BC系统使用的缓存不一致，导致缓存出问题的这种低级bug； 由于controller层简单没有逻辑，这样就可以避免目前由于后台管理系统单机，修改一个业务逻辑bug重启系统，导致后台不可用的问题，因为只需要重启dubbo就行了； 这样controller层变得很轻，只需要一个简单的servlet容器，对机器的要求会降低不少； 四. 备注
由于我工作时间不长，见过的系统更有限，所以对系统架构几乎没有什么经验，这些只是我个人的一点很粗浅的理解，例如把dubbo做的那么重，虽然可扩展性提高了不少，但其实也不知道算不算合理，因为调用rpc服务，肯定会增加网络IO延时，所以这些算是我个人的抛砖引玉吧，一方面希望对同样和我一样没有经验的小伙伴能有所帮助，另一方面希望有经验的小伙伴能留言交流
五. 总结
以上便是我个人对拉勾一拍所有的核心系统进行了审视后的一番分析，如果这些核心系统架构的重构真的达到自己的理想状况这将是一番浩大的工程，对于高速发展的互联网公司来说，这就是一边驾驶者一辆高速前进的汽车，一边对这辆汽车进行换轮胎换发动机，先不说工作量的问题，难度程度也可见一斑。
</p>
  </div>
  <footer class="entry-footer"><span title='2016-10-23 13:57:34 +0000 +0000'>October 23, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>46 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to 我看拉勾一拍之系统架构" href="http://localhost:1313/posts/2016-10-23-%E6%88%91%E7%9C%8B%E6%8B%89%E5%8B%BE%E4%B8%80%E6%8B%8D%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Dubbo远程debug方法
    </h2>
  </header>
  <div class="entry-content">
    <p>公司项目的rpc服务基于阿里巴巴的dubbo架构，开发dubbo项目的时候测试只能跑junit test，但实际工作中由于很多时候junit test写的不全，出了问题只能再加日志分析原因（典型的没事找事型），这次和公司移动端的推送联调IM服务，发现他们已经把老夫之前听说的远程debug用在了实际工作中，刚好趁此机会实验了一把，以下是笔记，以待自己和需要的朋友参考。
dubbo服务的设置 我们自己观察dubbo的start.sh和start.bat这两个脚本会发现有如下两端代码
①. start.sh
JAVA_DEBUG_OPTS=&#34;&#34; if [ &#34;$1&#34; = &#34;debug&#34; ]; then JAVA_DEBUG_OPTS=&#34; -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n &#34; fi ②. start.bat
if &#34;&#34;%1&#34;&#34; == &#34;&#34;debug&#34;&#34; goto debug if &#34;&#34;%1&#34;&#34; == &#34;&#34;jmx&#34;&#34; goto jmx java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main goto end :debug java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main goto end 也就是说，脚本已经支持远程debug，只需要的在启动的时候传入一个参数 debug 即可，其余的几乎不用做任何修改
eclipse的设置 当我们把远程的服务以支持debug的模式启动之后，就需要把本地的项目也起来了，否则怎么debug呢，本地的设置其实非常简单，一张图搞定
看了这张图，我相信不用我多说了，远程远程debug如此简单
</p>
  </div>
  <footer class="entry-footer"><span title='2016-08-14 21:28:15 +0000 +0000'>August 14, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>65 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Dubbo远程debug方法" href="http://localhost:1313/posts/2016-08-14-dubbo%E8%BF%9C%E7%A8%8Bdebug%E6%96%B9%E6%B3%95/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">多线程应用之批量数据处理
    </h2>
  </header>
  <div class="entry-content">
    <p>我们都知道多线程是为了加快数据处理的，但至于怎么用，因为在工作中，我一直很少用，所以对多线程不是很了解。之前处理一个功能时，由于没有经验，导致速度很慢，前一段时间经老大提示，可以用多线程解决，突然发现原来多线程可以这么用可以来处理这一类问题，今天记录一下，作为笔记也作为一个给读者的参考，好了先说一下问题：公司的业务的业务不仅分模块而且是分库分表的，这样就导致一个问题，当我们要查询一个数据时，不能连表查询，不能只通过一个接口获得数据，最容易想到的常规做法就是：
public List&lt;Data&gt; queryDatas() { List&lt;Data&gt; datas = queryDataFromDB(); if(null != datas &amp;&amp; datas.size() &gt; 0) { for(Data data : datas) { Object object = getObjectFromDb(data.getId()); data.setAttr1(object.getAttr); } } return datas; } 这么做，虽然可以满足业务需求，但效率实在是太低了，尤其是列表数据越大时，如果不只一个属性要这么做时，速度是会慢到要死人的。所以经老大提示参考同事的实现就采用了如下方法：
private static final ExecutorService executor = Executors.newFixedThreadPool(20); public List&lt;Data&gt; queryDatas() { List&lt;Data&gt; datas = queryDataFromDB(); if(null != datas &amp;&amp; datas.size() &gt; 0) { batchSetAttr(datas); } return datas; } private boolean batchSetAttr(final List&lt;Data&gt; datas) { final CompletionService&lt;Data&gt; completionService = new ExecutorCompletionService&lt;&gt;(executor); for (final Data data : datas) { completionService.submit(new Callable&lt;Data&gt;() { @Override public Data call() throws Exception { Object object = getObjectFromDb(data.getId()); data.setAttr1(object.getAttr); return data; } }); } try { for (int i = 0, size = datas.size(); i &lt; size; i&#43;&#43;) { Future&lt;Data&gt; future = completionService.take(); Data d = future.get(); } } catch (InterruptedException e) { logger.error(&#34;InterruptedException&#34;, e); return false; } catch (ExecutionException e) { logger.error(&#34;ExecutionException&#34;, e); return false; } return true; } 利用多线程批量查询，返回时一一设置值，最终达到提高速度的目的。
最后需要说明一点：线程池的大小，大家可以根据自己的实际情况来设置，并不是越大越好；
</p>
  </div>
  <footer class="entry-footer"><span title='2016-07-24 14:15:37 +0000 +0000'>July 24, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>148 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to 多线程应用之批量数据处理" href="http://localhost:1313/posts/2016-07-24-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E4%B9%8B%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">DFA算法应用之敏感词过滤
    </h2>
  </header>
  <div class="entry-content">
    <p>公司在做一个社区应用，由于我朝特色，众所周知社区应用有一个很重要的就是要进行敏感词的过滤，这块由一个同事负责，听他说，有一个算法叫DFA，可以做这个，个人比较感兴趣，就到网上查了一些资料，有一篇文章写的特别好，老夫的这篇文章就是把其核心的部分（就是怎么应用，老夫一直有一个观点，理论弱于实践，理论懂得再多不会用一点用没有，所以老夫认为应用是核心）摘出来，留作笔记，如果有想了解其原理的，请点击下方的参考资料，好了，既然是应用那么就直接上代码了：
package cn.bridgeli.dfa; import java.util.HashSet; import java.util.Iterator; import java.util.Map; import java.util.Set; public class SensitivewordFilter { @SuppressWarnings(&#34;rawtypes&#34;) private Map sensitiveWordMap = null; public static int minMatchTYpe = 1; // 最小匹配规则 public static int maxMatchType = 2; // 最大匹配规则 /** * 初始化敏感词库 */ public SensitivewordFilter() { sensitiveWordMap = new SensitiveWordInit().initKeyWord(); } /** * 判断文字是否包含敏感字符 * * @param txt * 文字 * @param matchType * 匹配规则 1：最小匹配规则，2：最大匹配规则 * @return 若包含返回true，否则返回false */ public boolean isContaintSensitiveWord(String txt, int matchType) { boolean flag = false; for (int i = 0; i &lt; txt.length(); i&#43;&#43;) { int matchFlag = this.CheckSensitiveWord(txt, i, matchType); // 判断是否包含敏感字符 if (matchFlag &gt; 0) { flag = true; } } return flag; } /** * 获取文字中的敏感词 * * @param txt * 文字 * @param matchType * 匹配规则&amp;nbsp;1：最小匹配规则，2：最大匹配规则 * @return */ public Set&lt;String&gt; getSensitiveWord(String txt, int matchType) { Set&lt;String&gt; sensitiveWordList = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; txt.length(); i&#43;&#43;) { int length = CheckSensitiveWord(txt, i, matchType); if (length &gt; 0) { sensitiveWordList.add(txt.substring(i, i &#43; length)); i = i &#43; length &amp;#8211; 1; // 减1的原因，是因为for会自增 } } return sensitiveWordList; } /** * 替换敏感字字符 * * @param txt * @param matchType * @param replaceChar \* 替换字符，默认\* */ public String replaceSensitiveWord(String txt, int matchType, String replaceChar) { String resultTxt = txt; Set&lt;String&gt; set = getSensitiveWord(txt, matchType); // 获取所有的敏感词 Iterator&lt;String&gt; iterator = set.iterator(); String word = null; String replaceString = null; while (iterator.hasNext()) { word = iterator.next(); replaceString = getReplaceChars(replaceChar, word.length()); resultTxt = resultTxt.replaceAll(word, replaceString); } return resultTxt; } /** * 获取替换字符串 * * @param replaceChar * @param length * @return */ private String getReplaceChars(String replaceChar, int length) { String resultReplace = replaceChar; for (int i = 1; i &lt; length; i&#43;&#43;) { resultReplace &#43;= replaceChar; } return resultReplace; } /** * 检查文字中是否包含敏感字符，检查规则如下：&lt;br&gt; * * @param txt * @param beginIndex * @param matchType * @return，如果存在，则返回敏感词字符的长度，不存在返回0 */ @SuppressWarnings({ &#34;rawtypes&#34; }) public int CheckSensitiveWord(String txt, int beginIndex, int matchType) { boolean flag = false; // 敏感词结束标识位：用于敏感词只有1位的情况 int matchFlag = 0; // 匹配标识数默认为0 char word = 0; Map nowMap = sensitiveWordMap; for (int i = beginIndex; i &lt; txt.length(); i&#43;&#43;) { word = txt.charAt(i); nowMap = (Map) nowMap.get(word); // 获取指定key if (nowMap != null) { // 存在，则判断是否为最后一个 matchFlag&#43;&#43;; // 找到相应key，匹配标识&#43;1 if (&#34;1&#34;.equals(nowMap.get(&#34;isEnd&#34;))) { // 如果为最后一个匹配规则,结束循环，返回匹配标识数 flag = true; // 结束标志位为true if (SensitivewordFilter.minMatchTYpe == matchType) { // 最小规则，直接返回,最大规则还需继续查找 break; } } } else { // 不存在，直接返回 break; } } if (matchFlag &lt; 2 || !flag) { // 长度必须大于等于1，为词 matchFlag = 0; } return matchFlag; } public static void main(String[] args) { SensitivewordFilter filter = new SensitivewordFilter(); System.out.println(&#34;敏感词的数量：&#34; &#43; filter.sensitiveWordMap.size()); String string = &#34;太多的伤感情怀也许只局限于饲养基地 荧幕中的情节，主人公尝试着去用某种方式渐渐的很潇洒地释自杀指南怀那些自己经历的伤感。&#34; &#43; &#34;然后法轮功 我们的扮演的角色就是跟随着主人公的喜红客联盟 怒哀乐而过于牵强的把自己的情感也附加于银幕情节中，然后感动就流泪，&#34; &#43; &#34;难过就躺在某一个人的怀里尽情的阐述心扉或者手机卡复制器一个人一杯红酒一部电影在夜三级片 深人静的晚上，关上电话静静的发呆着。&#34;; Set&lt;String&gt; set = filter.getSensitiveWord(string, 1); System.out.println(&#34;语句中包含敏感词的个数为：&#34; &#43; set.size() &#43; &#34;。包含：&#34; &#43; set); } } 这个主要是应用，DFA的核心是下面：
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-05-02 12:38:56 +0000 +0000'>May 2, 2016</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>710 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to DFA算法应用之敏感词过滤" href="http://localhost:1313/posts/2016-05-02-dfa%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B9%8B%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">记一次线上操作bug
    </h2>
  </header>
  <div class="entry-content">
    <p>身为程序猿，可以说天天都会遇到bug，今天没为什么记下这次bug呢？说来惭愧，因为这次bug是由于自己不仔细没有仔细检查没有测试就对线上数据下手造成的，一方面是记下这个bug的由来，修复方法和犯下的失误的地方，另一方面也是留下记录警示自己操作线上数据一定要小心再小心，还有就是不要对自己过于自信，测试很重要。
先说一下bug的缘由，19号晚上我们上线了一个新功能，有一个功能模块是另外一个同事负责的，所以对其实现不是很了解，但数据导入有老夫负责，所以数据导入的时候，有一个结束时间没有考虑清楚，只有日期没有时间（产品经理和另一位同事当时也没有给我说），所以数据库里面结束时间变成了默认的“00:00:00”，本来修起来应该很简单，读出来update一下时间就好了，但由于是部门间的协作，比较麻烦，就考虑用SQL解决，所以就写出了如下的SQL：
CREATE TABLE t_goods_bak AS SELECT REPLACE(a.endtime,&amp;#8217;00:00:00&amp;#8242;,&amp;#8217;23:59:59&amp;#8242;) end_time,a.* FROM t_goods a; ALTER TABLE \`commercialization\`.\`t_goods_bak\` CHANGE \`id\` \`id\` INT(11) DEFAULT 0 NOT NULL FIRST, CHANGE \`end_time\` \`end_time\` DATETIME CHARSET utf8 COLLATE utf8_general_ci NOT NULL AFTER \`endtime\`, CHANGE \`price\` \`price\` DECIMAL(10,2) NOT NULL COMMENT &amp;#8216;商品单价&amp;#8217; AFTER \`end_time\`; ALTER TABLE \`commercialization\`.\`t_goods_bak\` DROP COLUMN \`endtime\`; ALTER TABLE \`commercialization\`.\`t_goods_bak\` CHANGE \`end_time\` \`endtime\` VARCHAR(19) CHARSET utf8 COLLATE utf8_general_ci DEFAULT &amp;#8221; NOT NULL COMMENT &amp;#8216;商品失效时间&amp;#8217;; DROP TABLE \`t_goods_bak\`; RENAME TABLE \`commercialization\`.\`t_goods_bak\` TO \`commercialization\`.\`t_goods\`; 整体思想就是新建一张表，在新建这张表的时候，把数据修对，修对的数据放在了新添加的end_time字段，然后把这张新表t_goods_bak修改成和原来的表一致，最后把原表删除，再把这张表改一下名字，就达到了替换以前表的目的，所以就OK，看到这里也许有同学已经发现问题了：先别OK，你这新表没主键啊！！！
对，老夫当时就没有多想，以为就此OK了，所以就出现bug了，因为我没有仔细看SQL语句（这些SQL除了，第一句之外都是自动生成的），新表根本没主键，这还不是问题的关键，仔细看第二句SQL，id字段默认是0，所以所有插入的数据，默认值都是0，因为没有自增，这就是最为关键的两个问题。所以综上所述，关于修这个bug，老夫至少忘了如下几件事：
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-04-24 14:44:25 +0000 +0000'>April 24, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>98 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to 记一次线上操作bug" href="http://localhost:1313/posts/2016-04-24-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%93%8D%E4%BD%9Cbug/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring和websocket整合应用示例（下）
    </h2>
  </header>
  <div class="entry-content">
    <p>在上篇中，我们已经实现了websocket，但还有一个核心的业务实现类没有实现，这里我们就实现这个业务核心类，因为老夫参与的这个系统使用websocket发送消息，所以其实现就是如何发送消息了。
NewsListenerImpl的实现 package cn.bridgeli.websocket; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import cn.bridgeli.DateUtil; import cn.bridgeli.enumeration.PlatNewsCategoryType; import cn.bridgeli.model.PlatNewsVo; import cn.bridgeli.model.SearchCondition; import cn.bridgeli.quartz.impl.TimingJob; import cn.bridgeli.service.PlatNewsService; import org.apache.commons.lang.StringUtils; import org.json.simple.JSONArray; import org.json.simple.JSONObject; import org.quartz.*; import org.quartz.impl.StdSchedulerFactory; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.web.socket.TextMessage; import java.io.IOException; import java.util.Date; import java.util.List; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * @Description : 站内消息监听器实现 * @Date : 16-3-7 */ @Component public class NewsListenerImpl implements NewsListener{ private static final Logger logger = LoggerFactory.getLogger(NewsListenerImpl.class); Gson gson = new GsonBuilder().setDateFormat(&#34;yyyy-MM-dd HH:mm:ss&#34;).create(); //线程池 private ExecutorService executorService = Executors.newCachedThreadPool(); //任务调度 private SchedulerFactory sf = new StdSchedulerFactory(); @Autowired private PlatNewsService platNewsService; @Override public void afterPersist(PlatNewsVo platNewsVo) { logger.info(&#34;监听到有新消息添加。。。&#34;); logger.info(&#34;新消息为:&#34;&#43;gson.toJson(platNewsVo)); //启动线程 if(null != platNewsVo &amp;&amp; !StringUtils.isBlank(platNewsVo.getCurrentoperatoremail())){ //如果是定时消息 if(platNewsVo.getNewsType() == PlatNewsCategoryType.TIMING_TIME.getCategoryId()){ startTimingTask(platNewsVo); //定时推送 }else{ //立即推送 executorService.execute(new AfterConnectionEstablishedTask(platNewsVo.getCurrentoperatoremail())); } } } @Override public void afterConnectionEstablished(String email) { logger.info(&#34;建立websocket连接后推送新消息。。。&#34;); if(!StringUtils.isBlank(email)){ executorService.execute(new AfterConnectionEstablishedTask(email)); } } /** * @Description ： 如果新添加了定时消息，启动定时消息任务 * @param platNewsVo */ private void startTimingTask(PlatNewsVo platNewsVo){ logger.info(&#34;开始定时推送消息任务。。。&#34;); Date timingTime = platNewsVo.getTimingTime(); if(null == timingTime){ logger.info(&#34;定时消息时间为null。&#34;); return; } logger.info(&#34;定时推送任务时间为：&#34;&#43;DateUtil.date2String(timingTime)); JobDetail jobDetail= JobBuilder.newJob(TimingJob.class) .withIdentity(platNewsVo.getCurrentoperatoremail()&#43;&#34;定时消息&#34;&#43;platNewsVo.getId(), &#34;站内消息&#34;) .build(); //传递参数 jobDetail.getJobDataMap().put(&#34;platNewsService&#34;,platNewsService); jobDetail.getJobDataMap().put(&#34;userEmail&#34;,platNewsVo.getCurrentoperatoremail()); Trigger trigger= TriggerBuilder .newTrigger() .withIdentity(&#34;定时消息触发&#34;&#43;platNewsVo.getId(), &#34;站内消息&#34;) .startAt(timingTime) .withSchedule(SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(0) //时间间隔 .withRepeatCount(0) //重复次数 ) .build(); //启动定时任务 try { Scheduler sched = sf.getScheduler(); sched.scheduleJob(jobDetail,trigger); if(!sched.isShutdown()){ sched.start(); } } catch (SchedulerException e) { logger.info(e.toString()); } logger.info(&#34;完成开启定时推送消息任务。。。&#34;); } /** * @Description : 建立websocket链接后的推送线程 */ class AfterConnectionEstablishedTask implements Runnable{ String email ; public AfterConnectionEstablishedTask(String email){ this.email = email; } @Override public void run() { logger.info(&#34;开始推送消息给用户:&#34;&#43;email&#43;&#34;。。。&#34;); if(!StringUtils.isBlank(email)){ SearchCondition searchCondition = new SearchCondition(); searchCondition.setOperatorEmail(email); JSONArray jsonArray = new JSONArray(); for(PlatNewsCategoryType type : PlatNewsCategoryType.values()){ searchCondition.setTypeId(type.getCategoryId()); int count = platNewsService.countPlatNewsByExample(searchCondition); JSONObject object = new JSONObject(); object.put(&#34;name&#34;,type.name()); object.put(&#34;description&#34;,type.getDescription()); object.put(&#34;count&#34;,count); jsonArray.add(object); } if(null != jsonArray &amp;&amp; jsonArray.size()&gt;0){ UserSocketVo userSocketVo = WSSessionLocalCache.get(email); TextMessage reMessage = new TextMessage(gson.toJson(jsonArray)); try { if(null != userSocketVo){ //推送消息 userSocketVo.getWebSocketSession().sendMessage(reMessage); //更新推送时间 userSocketVo.setLastSendTime(DateUtil.getNowDate()); logger.info(&#34;完成推送新消息给用户:&#34;&#43;userSocketVo.getUserEmail()&#43;&#34;。。。&#34;); } } catch (IOException e) { logger.error(e.toString()); logger.info(&#34;站内消息推送失败。。。&#34;&#43;e.toString()); } } } logger.info(&#34;结束推送消息给&#34;&#43;email&#43;&#34;。。。&#34;); } } } 这个类就是websocket的核心业务的实现，其具体肯定和业务相关，由于业务的不同，实现肯定不同，因为老夫参与的系统是发送消息，所以里面最核心的一句就是：
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-04-04 14:14:24 +0000 +0000'>April 4, 2016</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>304 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Spring和websocket整合应用示例（下）" href="http://localhost:1313/posts/2016-04-04-spring%E5%92%8Cwebsocket%E6%95%B4%E5%90%88%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%E4%B8%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring和websocket整合应用示例（上）
    </h2>
  </header>
  <div class="entry-content">
    <p>嗯，这次真的仅仅是一个入门教程，因为老夫表示自己也不会。近期老夫参与开发公司的一个CRM系统，系统中有很多消息的推送，由一个同事负责，其用到了websocket技术，老夫比较感兴趣，删繁就简，整理了一个教程，留作自己笔记，因很多原理老夫也是不甚了了，以备将来用到了有资料可查。
maven依赖 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;4.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt; &lt;version&gt;4.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; spring-servlet的配置 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:context=&#34;http://www.springframework.org/schema/context&#34; xmlns:mvc=&#34;http://www.springframework.org/schema/mvc&#34; xmlns:tx=&#34;http://www.springframework.org/schema/tx&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns:websocket=&#34;http://www.springframework.org/schema/websocket&#34; xsi:schemaLocation=&#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket.xsd&#34;&gt; &amp;#8230;&amp;#8230; &lt;!&amp;#8211; websocket &amp;#8211;&gt; &lt;bean id=&#34;websocket&#34; class=&#34;cn.bridgeli.websocket.WebsocketEndPoint&#34;/&gt; &lt;websocket:handlers&gt; &lt;websocket:mapping path=&#34;/websocket&#34; handler=&#34;websocket&#34;/&gt; &lt;websocket:handshake-interceptors&gt; &lt;bean class=&#34;cn.bridgeli.websocket.HandshakeInterceptor&#34;/&gt; &lt;/websocket:handshake-interceptors&gt; &lt;/websocket:handlers&gt; &lt;/beans&gt; 其中，path对应的路径就是前段通过ws协议调的接口路径
HandshakeInterceptor的实现 package cn.bridgeli.websocket; import cn.bridgeli.utils.UserManager; import cn.bridgeli.util.DateUtil; import cn.bridgeli.sharesession.UserInfo; import org.apache.commons.lang.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.http.server.ServerHttpRequest; import org.springframework.http.server.ServerHttpResponse; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.socket.WebSocketHandler; import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor; import java.util.Date; import java.util.Map; /** * @Description :创建握手（handshake）接口 * @Date : 16-3-3 */ public class HandshakeInterceptor extends HttpSessionHandshakeInterceptor{ private static final Logger logger = LoggerFactory.getLogger(HandshakeInterceptor.class); @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception { logger.info(&#34;建立握手前&amp;#8230;&#34;); ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); UserInfo currUser = UserManager.getSessionUser(attrs.getRequest()); UserSocketVo userSocketVo = new UserSocketVo(); String email= &#34;&#34;; if(null != currUser){ email = currUser.getEmail(); } if(StringUtils.isBlank(email)){ email = DateUtil.date2String(new Date()); } userSocketVo.setUserEmail(email); attributes.put(&#34;SESSION_USER&#34;, userSocketVo); return super.beforeHandshake(request, response, wsHandler, attributes); } @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) { logger.info(&#34;建立握手后&amp;#8230;&#34;); super.afterHandshake(request, response, wsHandler, ex); } } 因为老夫不是很懂，所以最大限度的保留原代码，这其实就是从单点登录中取出当前登录用户，转成UserSocketVo对象，放到Map中。所以接下来我们看看UserSocketVo对象的定义
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-04-04 14:05:19 +0000 +0000'>April 4, 2016</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>464 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Spring和websocket整合应用示例（上）" href="http://localhost:1313/posts/2016-04-04-spring%E5%92%8Cwebsocket%E6%95%B4%E5%90%88%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%E4%B8%8A/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/categories/java/page/7/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/categories/java/page/9/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">分享技术带来的喜悦</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
