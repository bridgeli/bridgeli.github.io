<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数据一致性 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</link>
    <description>Recent content in 数据一致性 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 22 Jul 2017 05:07:07 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>巧用CAS解决数据一致性问题[转载]</title>
      <link>http://localhost:1313/posts/2017-07-22-%E5%B7%A7%E7%94%A8cas%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Sat, 22 Jul 2017 05:07:07 +0000</pubDate>
      <guid>http://localhost:1313/posts/2017-07-22-%E5%B7%A7%E7%94%A8cas%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E8%BD%AC%E8%BD%BD/</guid>
      <description>&lt;p&gt;这周不太忙的时候看了58到家沈剑老师的一系列的文章，感觉沈剑老师的文章做到了深入浅出，浅显易懂，看完收获很大，有些文章完美的解决了我一直一来的疑惑，所以转载到自己博客，希望对大家也有所帮助。&lt;/p&gt;
&lt;p&gt;原文出处微信公众号：架构师之路，微信号：road5858，链接地址：http://mp.weixin.qq.com/s/_XlzbmBSj_i-S2PkE5tI_w&lt;/p&gt;
&lt;p&gt;以下是原文：&lt;/p&gt;
&lt;p&gt;缘起：在高并发的分布式环境下，对于数据的查询与修改容易引发一致性问题，本文将分享一种非常简单但有效的优化方法。&lt;/p&gt;
&lt;p&gt;一、业务场景&lt;/p&gt;
&lt;p&gt;业务场景为，购买商品的过程要对余额进行查询与修改，大致的业务流程如下：&lt;br&gt;
（1）从数据库查询用户现有余额 SELECT money FROM t_yue WHERE uid=$uid，不妨设查询出来的$old_money=100元&lt;/p&gt;
&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2017/07/step1.png&#34; alt=&#34;step1&#34; width=&#34;229&#34; height=&#34;149&#34; class=&#34;alignnone size-full wp-image-373&#34; /&gt; 
&lt;p&gt;（2）业务层实施业务逻辑，比如购买一个80元的商品，并且打九折&lt;br&gt;
if($old_money&amp;gt; 80*0.9) $new_money=$old_money-80*0.9=28&lt;/p&gt;
&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2017/07/step2.png&#34; alt=&#34;step2&#34; width=&#34;243&#34; height=&#34;69&#34; class=&#34;alignnone size-full wp-image-374&#34; /&gt; 
&lt;p&gt;（3）将数据库中的余额进行修改 UPDAtE t_yue SET money=$new_money WHERE uid=$uid&lt;/p&gt;
&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2017/07/step3.png&#34; alt=&#34;step3&#34; width=&#34;243&#34; height=&#34;143&#34; class=&#34;alignnone size-full wp-image-375&#34; /&gt; 
&lt;p&gt;在并发量低的情况下，这个流程没有任何问题，原有金额100元，购买了80元的九折商品（72元），剩余28元。&lt;/p&gt;
&lt;p&gt;二、潜在的问题&lt;/p&gt;
&lt;p&gt;在分布式环境中，如果并发量很大，这种“查询+修改”的业务很容易出现数据不一致。极限情况下，可能出现这样的异常流程：&lt;br&gt;
（1）业务1和业务2同时查询余额，是100元&lt;/p&gt;
&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2017/07/step4.png&#34; alt=&#34;step4&#34; width=&#34;249&#34; height=&#34;181&#34; class=&#34;alignnone size-full wp-image-376&#34; /&gt; 
&lt;p&gt;（2）业务1和业务2进行逻辑计算，算出各自业务的余额，假设业务1算出的余额是28元，业务2算出的余额是38元&lt;/p&gt;
&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2017/07/step5.png&#34; alt=&#34;step5&#34; width=&#34;243&#34; height=&#34;89&#34; class=&#34;alignnone size-full wp-image-377&#34; /&gt; 
&lt;p&gt;（3）业务1对数据库中的余额先进行修改，设置成28元。&lt;br&gt;
业务2对数据库中的余额后进行修改，设置成38元。&lt;/p&gt;
&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2017/07/step6-300x120.png&#34; alt=&#34;step6&#34; width=&#34;300&#34; height=&#34;120&#34; class=&#34;alignnone size-medium wp-image-378&#34; /&gt; 
&lt;p&gt;此时异常出现了，原有金额100元，业务1扣除了72元，业务2扣除了62元，最后剩余38元。&lt;/p&gt;
&lt;p&gt;三、问题原因&lt;/p&gt;
&lt;p&gt;高并发环境下，对同一个数据的并发读（两边都读出余额是100）与并发写（一个写回28，一个写回38）导致的数据一致性问题。&lt;/p&gt;
&lt;p&gt;四、原因分析&lt;/p&gt;
&lt;p&gt;业务1的写回：原有金额100，这是一个初始状态，写回金额28，理论上只有在原有金额为100的时候才允许写回成功，这一步没问题。&lt;br&gt;
业务2的写回：的原有金额100，这是一个初始状态，写回金额38，理论上只有在原有金额为100的时候才允许写回成功，可实际上，这个时候数据库中的金额已经变为28了，这一步的写操作不应该成功。&lt;/p&gt;
&lt;p&gt;五、简易解决方案&lt;/p&gt;
&lt;p&gt;在set写回的时候，加上初始状态的条件compare，只有初始状态不变时，才允许set写回成功，这正是大家常说的“Compare And Set”（CAS），是一种常见的降低读写锁冲突，保证数据一致性的方法。&lt;/p&gt;
&lt;p&gt;六、业务的升级&lt;/p&gt;
&lt;p&gt;业务线使用CAS解决高并发时数据一致性问题，只需要在进行set操作时，compare一下初始值，如果初始值变换，不允许set成功。&lt;br&gt;
对于上文中的业务场景，只需要将“UPDAtEt_yue SET money=$new_money WHERE uid=$uid”升级为&lt;br&gt;
“UPDAtE t_yue SETmoney=$new_money WHERE uid=$uid AND money=$old_money”即可。&lt;br&gt;
并发操作发生时：&lt;br&gt;
业务1执行 =&amp;gt; UPDAtE t_yue SET money=28 WHERE uid=$uid AND money=100&lt;br&gt;
业务2执行 =&amp;gt; UPDAtE t_yue SET money=38 WHERE uid=$uid AND money=100&lt;br&gt;
【这两个操作同时进行时，只能有一个执行成功】。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
