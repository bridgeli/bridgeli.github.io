<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>多线程 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 多线程 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 07 Feb 2021 07:06:13 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用两个线程交替打印数字和字母</title>
      <link>http://localhost:1313/posts/2021-02-07-%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D/</link>
      <pubDate>Sun, 07 Feb 2021 07:06:13 +0000</pubDate>
      <guid>http://localhost:1313/posts/2021-02-07-%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D/</guid>
      <description>&lt;p&gt;前一段时间听马士兵老师讲课，讲到某公司的一个面试，两个线程，其中一个线程输出ABC，另一个线程输出123，如何控制两个线程交叉输出1A2B3C，由于本人多线程掌握的一直不是很好，所以听完这道题，个人感觉收获良多，这是一个学习笔记。这道题有多种解法，不过有些属于纯炫技，所以只记录常见的三种解法。首先看第一种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;park 和 unpark&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

import com.google.common.collect.Lists;

import java.util.List;  
import java.util.concurrent.locks.LockSupport;

/**  
* @author BridgeLi  
* @date 2021/2/6 16:14  
*/  
public class Thread_Communication_Park_Unpark {

static Thread t1 = null;  
static Thread t2 = null;

public static void main(String[] args) {

final List&amp;lt;Integer&amp;gt; integers = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7);  
final List&amp;lt;String&amp;gt; strings = Lists.newArrayList(&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;E&amp;#34;, &amp;#34;F&amp;#34;, &amp;#34;G&amp;#34;);

t1 = new Thread(() -&amp;gt; integers.forEach(item -&amp;gt; {  
System.out.print(item);  
LockSupport.unpark(t2);  
LockSupport.park();  
}), &amp;#34;t1&amp;#34;);

t2 = new Thread(() -&amp;gt; strings.forEach(item -&amp;gt; {  
LockSupport.park();  
System.out.print(item);  
LockSupport.unpark(t1);  
}), &amp;#34;t2&amp;#34;);

t1.start();  
t2.start();  
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个是最简单的实现方法，LockSupport.park() 使当前线程阻塞，而 LockSupport.unpark() 则表示唤醒一个线程，所以他需要一个参数，表示你要唤醒哪个线程，很好理解，也比较简单。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java Thread 同步</title>
      <link>http://localhost:1313/posts/2018-05-12-java-thread-%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Sat, 12 May 2018 13:33:53 +0000</pubDate>
      <guid>http://localhost:1313/posts/2018-05-12-java-thread-%E5%90%8C%E6%AD%A5/</guid>
      <description>&lt;p&gt;之前遇到一个问题，就是如何让线程同步，由于自己多线程的东西实在不懂，所以不知道怎么办，但感觉应该是一个很简单的东西，所以就从网上搜一下资料，原来如此简单，直接调用 join 方法就好了。写篇博客记录一下 join 的使用方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。具体看代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

public class ThreadTest {

public static void main(String[] args) throws InterruptedException {  
ThreadJoinTest t1 = new ThreadJoinTest(&amp;#34;bridgeli&amp;#34;);  
ThreadJoinTest t2 = new ThreadJoinTest(&amp;#34;liqiao&amp;#34;);  
t1.start();  
/**  
* join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：  
* 程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕  
* 所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会  
*  
* join方法可以传递参数，join(10000)表示main线程会等待t1线程10毫秒，10毫秒过去后，  
* main线程和t1线程之间执行顺序由串行执行变为普通的并行执行  
*/  
t1.join(10000);  
t2.start();  
}

}

package cn.bridgeli.demo;

public class ThreadJoinTest extends Thread {  
public ThreadJoinTest(String name) {  
super(name);  
}

@Override  
public void run() {  
for (int i = 0; i &amp;lt; 100; i++) {  
System.out.println(this.getName() + &amp;#34;:&amp;#34; + i);  
try {  
Thread.sleep(1000);  
} catch (InterruptedException e) {  
e.printStackTrace();  
}  
}  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面注释也大概说明了 join 方法的作用：在 主线程 中调用了 t1 线程的 join() 方法时，表示只有当 t1 线程执行完毕时，主线程 才能继续执行，也就是开始执行 t2。注意，join 方法其实也可以传递一个参数给它的，表示：如果 主线程 在 t1 执行 1000 毫秒之后，继续执行，也就是开启 t2 线程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ThreadLocal类之简单理解</title>
      <link>http://localhost:1313/posts/2017-06-11-threadlocal%E7%B1%BB%E4%B9%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 11 Jun 2017 12:21:40 +0000</pubDate>
      <guid>http://localhost:1313/posts/2017-06-11-threadlocal%E7%B1%BB%E4%B9%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;当年实习的时候，当时公司一个相当有经验的工程师zeak带我们，从他那第一次听说了ThreadLocal类，但由于自己基础薄弱，没有理解到底怎么回事，工作中也没有用过，就一直没有太放在心上，刚好这一段时间不太忙，仔细玩了一下，欢迎高手批评。&lt;br&gt;
ThreadLocal，线程本地变量。他为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。简单理解就是，对于非线程安全的变量在线程内部共享不用每次都new，是一种空间换时间的做法。ThreadLocal类提供的几个方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
public T get() { }  
public void set(T value) { }  
public void remove() { }  
protected T initialValue() { }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看名字就知道这些方法是干嘛的了，下面我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。首先是get方法的实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
public T get() {  
Thread t = Thread.currentThread();  
ThreadLocalMap map = getMap(t);  
if (map != null) {  
ThreadLocalMap.Entry e = map.getEntry(this);  
if (e != null)  
return (T)e.value;  
}  
return setInitialValue();  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&amp;lt;key,value&amp;gt;键值对，注意这里获取键值对传进去的是 this，而不是当前线程t。如果获取成功，则返回value值。如果map为空，则调用setInitialValue方法返回value。那么getMap方法中又做了什么呢？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
ThreadLocalMap getMap(Thread t) {  
return t.threadLocals;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原来是返回当前线程t中的一个成员变量threadLocals，而threadLocals则是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
ThreadLocal.ThreadLocalMap threadLocals = null;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那就看看ThreadLocalMap的实现了：&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于synchronized用法的简单理解</title>
      <link>http://localhost:1313/posts/2017-05-14-%E5%85%B3%E4%BA%8Esynchronized%E7%94%A8%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 14 May 2017 09:20:14 +0000</pubDate>
      <guid>http://localhost:1313/posts/2017-05-14-%E5%85%B3%E4%BA%8Esynchronized%E7%94%A8%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;synchronized 关键字既可以用于声明方法，也可以用于声明代码块，他们之间有什么区别呢？下面让我们逐一测试一下。&lt;br&gt;
先看以第一个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package demo;

public class SynchronizedDemo1 {

public synchronized static void foo1() {  
}

public synchronized static void foo2() {  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，foo1 和 foo2 是类的两个静态方法。在不同的线程中，这两个方法的调用时互斥的，不仅是他们之间，任何两个不同的线程的调用也互斥。下面看第二个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package demo;

public class SynchronizedDemo2 {

public synchronized void foo3() {  
}

public synchronized void foo4() {  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，foo3 和 foo4 是类的两个成员方法，在多线程环境中，调用同一个对象的 foo3 或者 foo4 是互斥的，与上一个例子的差别在于，这是针对同一个对象的多线程方法调用互斥。下面再看最后一个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package demo;

public class SynchronizedDemo3 {

public void foo5() {  
synchronized (this) {

}  
}

public void foo6() {  
synchronized (SynchronizedDemo3.class) {

}  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，synchronized 用来修饰代码块，需要注意的是：synchronized 后面会有一个参数，其实这个就是用于同步的锁所属的对象。在这个例子中 synchronized (this) 与 SynchronizedDemo2 中加 synchronized 的成员方法是互斥的，而 synchronized (SynchronizedDemo3.class) 与 SynchronizedDemo1 中加 synchronized 的静态方法是互斥的。synchronized 用于修饰代码块会更加灵活，因为除了前面的这个例子外，synchronized 后面的参数可以是任意对象。&lt;/p&gt;</description>
    </item>
    <item>
      <title>多线程应用之批量数据处理</title>
      <link>http://localhost:1313/posts/2016-07-24-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E4%B9%8B%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 24 Jul 2016 14:15:37 +0000</pubDate>
      <guid>http://localhost:1313/posts/2016-07-24-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E4%B9%8B%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</guid>
      <description>&lt;p&gt;我们都知道多线程是为了加快数据处理的，但至于怎么用，因为在工作中，我一直很少用，所以对多线程不是很了解。之前处理一个功能时，由于没有经验，导致速度很慢，前一段时间经老大提示，可以用多线程解决，突然发现原来多线程可以这么用可以来处理这一类问题，今天记录一下，作为笔记也作为一个给读者的参考，好了先说一下问题：公司的业务的业务不仅分模块而且是分库分表的，这样就导致一个问题，当我们要查询一个数据时，不能连表查询，不能只通过一个接口获得数据，最容易想到的常规做法就是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
public List&amp;lt;Data&amp;gt; queryDatas() {  
List&amp;lt;Data&amp;gt; datas = queryDataFromDB();  
if(null != datas &amp;amp;&amp;amp; datas.size() &amp;gt; 0) {  
for(Data data : datas) {  
Object object = getObjectFromDb(data.getId());  
data.setAttr1(object.getAttr);  
}  
}

return datas;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这么做，虽然可以满足业务需求，但效率实在是太低了，尤其是列表数据越大时，如果不只一个属性要这么做时，速度是会慢到要死人的。所以经老大提示参考同事的实现就采用了如下方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
private static final ExecutorService executor = Executors.newFixedThreadPool(20);

public List&amp;lt;Data&amp;gt; queryDatas() {  
List&amp;lt;Data&amp;gt; datas = queryDataFromDB();  
if(null != datas &amp;amp;&amp;amp; datas.size() &amp;gt; 0) {  
batchSetAttr(datas);  
}  
return datas;  
}

private boolean batchSetAttr(final List&amp;lt;Data&amp;gt; datas) {  
final CompletionService&amp;lt;Data&amp;gt; completionService = new ExecutorCompletionService&amp;lt;&amp;gt;(executor);  
for (final Data data : datas) {  
completionService.submit(new Callable&amp;lt;Data&amp;gt;() {  
@Override  
public Data call() throws Exception {  
Object object = getObjectFromDb(data.getId());  
data.setAttr1(object.getAttr);  
return data;  
}  
});  
}

try {  
for (int i = 0, size = datas.size(); i &amp;lt; size; i++) {  
Future&amp;lt;Data&amp;gt; future = completionService.take();  
Data d = future.get();  
}  
} catch (InterruptedException e) {  
logger.error(&amp;#34;InterruptedException&amp;#34;, e);  
return false;  
} catch (ExecutionException e) {  
logger.error(&amp;#34;ExecutionException&amp;#34;, e);  
return false;  
}

return true;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;利用多线程批量查询，返回时一一设置值，最终达到提高速度的目的。&lt;br&gt;
最后需要说明一点：线程池的大小，大家可以根据自己的实际情况来设置，并不是越大越好；&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
