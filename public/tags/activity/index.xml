<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Activity on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/activity/</link>
    <description>Recent content in Activity on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 01 Feb 2015 15:04:36 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/activity/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android之Activity之间的参数传递</title>
      <link>http://localhost:1313/posts/2015-02-01-android%E4%B9%8Bactivity%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sun, 01 Feb 2015 15:04:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/2015-02-01-android%E4%B9%8Bactivity%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid>
      <description>&lt;p&gt;前面写了很多activity的东西，什么生命周期之类、常用控件以及这些控件怎么布局之类的，今天从另外一个角度在看activity：一个应用其实就是不同activity的切换，然后展示一些数据给用户，但是不同的activity之前肯定有着联系，那么他们之间怎么联系呢？说白了就是他们之间的参数是如何传递的呢？在讲不同的activity之间相互传参之前，我们先看这样两个问题：①：我们有时候需要从一个activity跳转到另一个activity，并且同时把参数带过去，然后一般就没有第一个activity啥事了，这个很常见所以就不举例子了，我们暂且称这一种为：普通的参数传递；②：有些时候呢，却不是这样，我们需要在第一个activity中打开第二个activity，在第二个activity中选取一个内容后，把我们选取的参数带回第一个activity，然后在第一个activity中处理带回来的参数，例如：我们在上传头像时，我们在第一个activity中，打开第二个activity，然后在第二个activity中，选取图片、裁剪图片，然后把处理好之后的图片带回到第一个activity，我们暂且称这种叫：关心结果的参数传递。&lt;br&gt;
在明白有这两种需求之后，我们发现不同的activity之间参数传递其实很简单，不同的activity之间传递参数是依靠一个对象：android.content.Intent，只要有这个对象就可以满足我们在不同的activity之间传递参数的需求了。下面就让我们结合这两种情况，看看不同activity之间参数如何传递。&lt;/p&gt;
&lt;p&gt;一、普通的参数传递&lt;br&gt;
废话不多说，先看例子：&lt;/p&gt;
&lt;p&gt;主activity的代码如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package cn.bridgeli.demo;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

public class MainActivity extends Activity {

    private EditText factorOne = null;
    private TextView symbol = null;
    private EditText factorTwo = null;
    private Button calc = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        factorOne = (EditText) findViewById(R.id.factorOne);
        symbol = (TextView) findViewById(R.id.symbol);
        symbol.setText(&amp;#34;乘以&amp;#34;);
        factorTwo = (EditText) findViewById(R.id.factorTwo);

        calc = (Button) findViewById(R.id.calc);
        calc.setText(&amp;#34;计算&amp;#34;);
        calc.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View arg0) {
                String firstNum = factorOne.getText().toString();
                String secondNum = factorTwo.getText().toString();
                Intent intent = new Intent();
                intent.setClass(MainActivity.this, ResultActivity.class);
                intent.putExtra(&amp;#34;firstNum&amp;#34;, firstNum);
                intent.putExtra(&amp;#34;secondNum&amp;#34;, secondNum);
                startActivity(intent);
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其对应的布局文件：activity_main.xml&lt;/p&gt;</description>
    </item>
    <item>
      <title>Activity之常见布局初步</title>
      <link>http://localhost:1313/posts/2015-01-18-activity%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%88%9D%E6%AD%A5/</link>
      <pubDate>Sun, 18 Jan 2015 14:53:40 +0000</pubDate>
      <guid>http://localhost:1313/posts/2015-01-18-activity%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%88%9D%E6%AD%A5/</guid>
      <description>&lt;p&gt;前一篇博客记录了在activity中有哪些控件可供我们使用，既然牵涉到控件，那么肯定会牵涉到控件的布局，也就是在activity中怎么摆放这些东西，我们先看看activity的布局方式有哪些：LinearLayout线性布局、TableLayout表格布局、RelativeLayout相对布局、AbsoluteLayout绝对布局、FrameLayout帧布局等五种，各有各的用途和用法，其中老夫认为最常用的是前三种，最最常用的应该就是前两种了，今天我们就介绍一下前三种的用法。&lt;/p&gt;
&lt;p&gt;首先看第一个也是非常常见的也是非常简单的LinearLayout线性布局方式，布局文件为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;  
xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34;  
android:layout_width=&amp;#34;match_parent&amp;#34;  
android:layout_height=&amp;#34;match_parent&amp;#34;  
android:orientation=&amp;#34;vertical&amp;#34; &amp;gt;

&amp;lt;!&amp;amp;#8211;  
android:id 为控件指定相应的ID  
android:text 指定控件中显示的文字，需要注意的是：这里最好使用strings.xml  
android:gravity 指定控件中内容的基本位置，比如居中、靠左等  
android:textSize 指定控件中字体的大小  
android:background 指定控件的背景色，使用RGB命名法  
android:width 指定控件的宽度  
android:height 指定控件的高度  
android:layout_width 和父控件的关系，例如是匹配内容还是在水平方向上填满父控件  
android:layout_height 和父控件的关系，例如是匹配内容还是在垂直方向上填满父控件  
android:padding* 指定控件的内边距，也就是说控件中内容  
android:singleLine= 布尔值，如果为真，则控件中的内容将在一行中显示  
&amp;amp;#8211;&amp;gt;

&amp;lt;TextView  
android:id=&amp;#34;@+id/firstTextView&amp;#34;  
android:text=&amp;#34;第一行&amp;#34;  
android:gravity=&amp;#34;center_vertical&amp;#34;  
android:textSize=&amp;#34;20pt&amp;#34;  
android:background=&amp;#34;#ff0000&amp;#34;  
android:layout_width=&amp;#34;wrap_content&amp;#34;  
android:layout_height=&amp;#34;wrap_content&amp;#34;  
android:paddingLeft=&amp;#34;10dip&amp;#34;  
android:paddingTop=&amp;#34;20dip&amp;#34;  
android:paddingRight=&amp;#34;30dip&amp;#34;  
android:paddingBottom=&amp;#34;40dip&amp;#34;  
android:singleLine=&amp;#34;false&amp;#34;  
/&amp;gt;  
&amp;lt;TextView  
android:id=&amp;#34;@+id/secondTextView&amp;#34;  
android:text=&amp;#34;第二行&amp;#34;  
android:gravity=&amp;#34;center_vertical&amp;#34;  
android:textSize=&amp;#34;30pt&amp;#34;  
android:background=&amp;#34;#00ff00&amp;#34;  
android:layout_width=&amp;#34;wrap_content&amp;#34;  
android:layout_height=&amp;#34;wrap_content&amp;#34;  
/&amp;gt;  
&amp;lt;/LinearLayout&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中LinearLayout表示采用线性布局方式，第五行：android:orientation=”vertical”表示是在水平方向还是在垂直方向上线性布局，注释中为该元素设置样式的各种含义。&lt;br&gt;
需要说明的是，LinearLayout是可以嵌套的，下面给出一个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;  
xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34;  
android:layout_width=&amp;#34;match_parent&amp;#34;  
android:layout_height=&amp;#34;match_parent&amp;#34;  
android:orientation=&amp;#34;vertical&amp;#34; &amp;gt;

&amp;lt;LinearLayout  
android:layout_width=&amp;#34;match_parent&amp;#34;  
android:layout_height=&amp;#34;match_parent&amp;#34;  
android:orientation=&amp;#34;vertical&amp;#34;  
android:layout_weight=&amp;#34;1&amp;#34; &amp;gt;

&amp;lt;TextView  
android:id=&amp;#34;@+id/firstTextView&amp;#34;  
android:text=&amp;#34;第一行&amp;#34;  
android:gravity=&amp;#34;center_vertical&amp;#34;  
android:textSize=&amp;#34;20pt&amp;#34;  
android:background=&amp;#34;#ff0000&amp;#34;  
android:layout_width=&amp;#34;wrap_content&amp;#34;  
android:layout_height=&amp;#34;wrap_content&amp;#34;  
android:paddingLeft=&amp;#34;10dip&amp;#34;  
android:paddingTop=&amp;#34;20dip&amp;#34;  
android:paddingRight=&amp;#34;30dip&amp;#34;  
android:paddingBottom=&amp;#34;40dip&amp;#34;  
android:singleLine=&amp;#34;false&amp;#34;  
/&amp;gt;  
&amp;lt;TextView  
android:id=&amp;#34;@+id/secondTextView&amp;#34;  
android:text=&amp;#34;第二行&amp;#34;  
android:gravity=&amp;#34;center_vertical&amp;#34;  
android:textSize=&amp;#34;30pt&amp;#34;  
android:background=&amp;#34;#00ff00&amp;#34;  
android:layout_width=&amp;#34;wrap_content&amp;#34;  
android:layout_height=&amp;#34;wrap_content&amp;#34;  
/&amp;gt;  
&amp;lt;/LinearLayout&amp;gt;

&amp;lt;LinearLayout  
android:layout_width=&amp;#34;match_parent&amp;#34;  
android:layout_height=&amp;#34;match_parent&amp;#34;  
android:orientation=&amp;#34;vertical&amp;#34;  
android:layout_weight=&amp;#34;1&amp;#34; &amp;gt;

&amp;lt;TextView  
android:id=&amp;#34;@+id/firstTextView&amp;#34;  
android:text=&amp;#34;第一行&amp;#34;  
android:gravity=&amp;#34;center_vertical&amp;#34;  
android:textSize=&amp;#34;20pt&amp;#34;  
android:background=&amp;#34;#ff0000&amp;#34;  
android:layout_width=&amp;#34;wrap_content&amp;#34;  
android:layout_height=&amp;#34;wrap_content&amp;#34;  
android:paddingLeft=&amp;#34;10dip&amp;#34;  
android:paddingTop=&amp;#34;20dip&amp;#34;  
android:paddingRight=&amp;#34;30dip&amp;#34;  
android:paddingBottom=&amp;#34;40dip&amp;#34;  
android:singleLine=&amp;#34;false&amp;#34;  
/&amp;gt;  
&amp;lt;TextView  
android:id=&amp;#34;@+id/secondTextView&amp;#34;  
android:text=&amp;#34;第二行&amp;#34;  
android:gravity=&amp;#34;center_vertical&amp;#34;  
android:textSize=&amp;#34;30pt&amp;#34;  
android:background=&amp;#34;#00ff00&amp;#34;  
android:layout_width=&amp;#34;wrap_content&amp;#34;  
android:layout_height=&amp;#34;wrap_content&amp;#34;  
/&amp;gt;  
&amp;lt;/LinearLayout&amp;gt;  
&amp;lt;/LinearLayout&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于嵌套需要说明的是，1. 最外层的android:orientation=”vertical”表示内部所有的LinearLayout的布局方式，当然每一个LinearLayout的android:orientation=”vertical”表明自己内部每一个元素的布局方式；2. 每一个LinearLayout的android:layout_weight=”1″表示该LinearLayout的权重，即该LinearLayout在所有空间中所占的比例。最后需要说明的是，这个我是把第一个文件直接拷过去的，所以ID有重复，大家记得改一下&lt;br&gt;
下面我们看第二种布局方式：TableLayout表格布局，其中我个人感觉这种布局方式用的应该不是很多，下面我们看看其布局文件：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Activity之生命周期</title>
      <link>http://localhost:1313/posts/2015-01-04-activity%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sun, 04 Jan 2015 15:08:13 +0000</pubDate>
      <guid>http://localhost:1313/posts/2015-01-04-activity%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>&lt;p&gt;这几天没事，自学了一下Android的开发，今天记录一下activity的生命周期，在写之前，我们先看一下，Google官方的文档，窃以为这个说的已经比较清楚明白了：&lt;br&gt;
&lt;a href=&#34;https://www.bridgeli.cn/wp-content/uploads/2015/01/activity_lifecycle.png&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2015/01/activity_lifecycle-232x300.png&#34; alt=&#34;activity_lifecycle&#34; width=&#34;232&#34; height=&#34;300&#34; class=&#34;alignnone size-medium wp-image-133&#34; /&gt;&lt;/a&gt;&lt;br&gt;
从这张图，我们清楚无误的看到，activity的生命周期方法执行顺序为：onCreate()–&amp;gt;onStart()–&amp;gt;onResume()–&amp;gt;onPause()–&amp;gt;onStop()–&amp;gt;onRestart()–&amp;gt;ondestory()&lt;br&gt;
但是口说无凭，我们从一个例子中说明问题：&lt;br&gt;
第一个activity：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package cn.bridgeli.lifecycle;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {

    private Button button = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        button = (Button) findViewById(R.id.button);
        ButtonListener buttonListener = new ButtonListener();
        button.setOnClickListener(buttonListener);

        System.out.println(&amp;#34;First activity onCreate&amp;#34;);
    }

    class ButtonListener implements OnClickListener{

        @Override
        public void onClick(View arg0) {
            Intent intent = new Intent();
            intent.setClass(MainActivity.this, SecondActivity.class);
            startActivity(intent);
        }

    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        System.out.println(&amp;#34;First activity onDestroy&amp;#34;);
    }

    @Override
    protected void onPause() {
        System.out.println(&amp;#34;First activity onPause&amp;#34;);
        super.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
        System.out.println(&amp;#34;First activity onResume&amp;#34;);
    }

    @Override
    protected void onStart() {
        super.onStart();
        System.out.println(&amp;#34;First activity onStart&amp;#34;);
    }

    @Override
    protected void onStop() {
        super.onStop();
        System.out.println(&amp;#34;First activity onStop&amp;#34;);
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        System.out.println(&amp;#34;First activity onRestart&amp;#34;);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个activity：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
