<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>分布式 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 31 Mar 2019 15:12:55 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于 CAP 理论 和 BASE 理论</title>
      <link>http://localhost:1313/posts/2019-03-31-%E5%85%B3%E4%BA%8E-cap-%E7%90%86%E8%AE%BA-%E5%92%8C-base-%E7%90%86%E8%AE%BA/</link>
      <pubDate>Sun, 31 Mar 2019 15:12:55 +0000</pubDate>
      <guid>http://localhost:1313/posts/2019-03-31-%E5%85%B3%E4%BA%8E-cap-%E7%90%86%E8%AE%BA-%E5%92%8C-base-%E7%90%86%E8%AE%BA/</guid>
      <description>&lt;p&gt;一、CAP 理论&lt;/p&gt;
&lt;p&gt;CAP 理论是分布式计算领域公认的一个定理，是分布式架构师必须掌握的理论，目前网上关于这块的资料也很多，各种说法，其实 CAP 理论自身也是一个不断发展的过程，相比之下比较准确的说法应该是：在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。也就是说必须是相关连接并且共享数据的分布式系统才是我们讨论 CAP 的基础，另外就是 CAP 理论关注的是对数据的读写操作，而不是分布式系统的所有功能。明白了这些之后，下面对 CAP 逐一讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一致性（Consistency）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很多资料都说，对一致性的讲解时所有节点在同一时刻都能看到相同的数据，其实更准确的应该是：对某个客户端来说，读操作保证能够返回最新的写操作结果，是否数据一定一直呢？还真不一定，对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致，因为事务在执行过程中，client 是无法读取到未提交的数据的，只有等到事务提交后，client 才能读取到事务写入的数据，而如果事务失败则会进行回滚，client 也不会读取到事务中间写入的数据。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;可用性（Availability）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般的解释是，每个请求都能得到成功或者失败的响应，更准确的是，非故障的节点在合理的时间内返回合理的响应（不是错误和超时的相应），其实什么是成功和失败？超时报错算不算失败的响应？所以应该是合理的响应，另外故障节点肯定是不能返回结果了。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;分区容错性（Partition Tolerance）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般说法是，出现消息丢失或者分区错误时系统能够继续运行，其实更准确的是，当出现网络分区后，系统能够继续“履行职责”。因为关于运行，只要不宕机就可以说在运行。&lt;br&gt;
综上，其实 CAP 理论也是一个自身不断发展的历程，虽然以前的理论也能说明问题，但是仔细深究起来发现有些问题，下面会有说明。&lt;/p&gt;
&lt;p&gt;CAP 应用&lt;/p&gt;
&lt;p&gt;CAP 理论开明宗义就说我们必须放弃一个，但是其实仔细想想我们可以放弃 P 吗？因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象。如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证 C，系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A 冲突了，因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 结果，但是需要说明的是，按照通常解释，是可以 CA 的，因为通常的解释 A 是返回失败或者成功的结果，而不允许写入，其实就是失败的结果，满足 A 的定义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了保证一致性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 需要返回 Error，提示客户端 C“系统现在发生了错误”，这种处理方式违背了 A 的要求，因此 CAP 三者只能满足 CP&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dubbo和zookeeper入门实例</title>
      <link>http://localhost:1313/posts/2015-07-26-dubbo%E5%92%8Czookeeper%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sun, 26 Jul 2015 14:05:52 +0000</pubDate>
      <guid>http://localhost:1313/posts/2015-07-26-dubbo%E5%92%8Czookeeper%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/</guid>
      <description>&lt;p&gt;公司项目里用到了dubbo，感觉挺好玩，以前没有玩过，自己抽时间就小小研究了一下，今天记录一下自己的学习成果。&lt;br&gt;
关于Dubbo和zookeeper是干嘛的，网上一搜一大堆所以就不多做介绍了，想了解的可以自己搜搜看，今天就只记录怎么跑一个最基本的Dubbo和zookeeper小示例程序是怎么跑起来的，当然虽然是一个demo，但和真实环境也是无差的哦。&lt;/p&gt;
&lt;p&gt;一. 安装zookeeper&lt;/p&gt;
&lt;p&gt;要想使用Dubbo，必须给Dubbo一个注册中心，当然这个注册中心不一定必须是zookeeper，也可以是redis等，但用zookeeper是一个相对比较好的方式，咱们暂且就这么办。&lt;br&gt;
关于zookeeper的安装，老夫窃以为这篇文章写得非常棒，就不多赘述了，大家可以直接参考：http://blog.csdn.net/wxwzy738/article/details/16330253，看了这篇文章，大家立马就会就明白怎么一回事了，看过自知。&lt;/p&gt;
&lt;p&gt;二. Dubbo实现&lt;/p&gt;
&lt;p&gt;Dubbo的实现肯定是要靠自己写代码啦，我的代码使用maven编译的，引入的jar文件如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;依赖的jar文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;  
&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;  
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;2.5.3&amp;lt;/version&amp;gt;  
&amp;lt;exclusions&amp;gt;  
&amp;lt;exclusion&amp;gt;  
&amp;lt;artifactId&amp;gt;spring&amp;lt;/artifactId&amp;gt;  
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
&amp;lt;/exclusion&amp;gt;  
&amp;lt;/exclusions&amp;gt;  
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;0.5&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中junit和spring-test大家肯定看出来是干嘛的了，为了跑测试，Dubbo分为生产者和消费者，接下来我们先看看生产者是怎么实现的&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;生产者的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;①. 配置文件applicationProvider.xml&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;  
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34;  
xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;  
xmlns:dubbo=&amp;#34;http://code.alibabatech.com/schema/dubbo&amp;#34;  
xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34;  
xsi:schemaLocation=&amp;#34;  
http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
http://www.springframework.org/schema/context  
http://www.springframework.org/schema/context/spring-context-3.0.xsd  
http://code.alibabatech.com/schema/dubbo  
http://code.alibabatech.com/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt;

&amp;lt;!&amp;amp;#8211; Auto Scan &amp;amp;#8211;&amp;gt;  
&amp;lt;context:component-scan base-package=&amp;#34;cn.bridgeli.provider&amp;#34; /&amp;gt;

&amp;lt;!&amp;amp;#8211; Application name &amp;amp;#8211;&amp;gt;  
&amp;lt;dubbo:application name=&amp;#34;hello-world-app&amp;#34; /&amp;gt;

&amp;lt;!&amp;amp;#8211; registry address, used for service to register itself &amp;amp;#8211;&amp;gt;  
&amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34; /&amp;gt;

&amp;lt;!&amp;amp;#8211; expose this service through dubbo protocol, through port 20880 &amp;amp;#8211;&amp;gt;  
&amp;lt;!&amp;amp;#8211;  
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34; /&amp;gt;  
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;9090&amp;#34; server=&amp;#34;netty&amp;#34;  
client=&amp;#34;netty&amp;#34; codec=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;hessian2&amp;#34; charset=&amp;#34;UTF-8&amp;#34;  
threadpool=&amp;#34;fixed&amp;#34; threads=&amp;#34;100&amp;#34; queues=&amp;#34;0&amp;#34; iothreads=&amp;#34;9&amp;#34; buffer=&amp;#34;8192&amp;#34;  
accepts=&amp;#34;1000&amp;#34; payload=&amp;#34;8388608&amp;#34; /&amp;gt;  
&amp;amp;#8211;&amp;gt;  
&amp;lt;!&amp;amp;#8211; Service interface Concurrent Control &amp;amp;#8211;&amp;gt;  
&amp;lt;!&amp;amp;#8211; &amp;lt;dubbo:service interface=&amp;#34;cn.bridgeli.provider.service.ProviderService&amp;#34; ref=&amp;#34;providerService&amp;#34;/&amp;gt; &amp;amp;#8211;&amp;gt;  
&amp;lt;!&amp;amp;#8211; 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 &amp;amp;#8211;&amp;gt;  
&amp;lt;dubbo:annotation package=&amp;#34;cn.bridgeli.provider.service&amp;#34; /&amp;gt;  
&amp;lt;!&amp;amp;#8211; Default Protocol &amp;amp;#8211;&amp;gt;  
&amp;lt;!&amp;amp;#8211;  
&amp;lt;dubbo:protocol server=&amp;#34;netty&amp;#34; /&amp;gt;  
&amp;amp;#8211;&amp;gt;  
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注释很详细，不解释，就是dubbo和spring的集成&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
