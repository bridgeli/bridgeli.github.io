<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>POI on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/poi/</link>
    <description>Recent content in POI on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 13 Mar 2016 14:13:56 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/poi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>POI解析Excel示例</title>
      <link>http://localhost:1313/posts/2016-03-13-poi%E8%A7%A3%E6%9E%90excel%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Sun, 13 Mar 2016 14:13:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/2016-03-13-poi%E8%A7%A3%E6%9E%90excel%E7%A4%BA%E4%BE%8B/</guid>
      <description>&lt;p&gt;在Java的世界里，对于解析Excel，目前市场上有两个不错的框架，一个是jxl另一个是poi，之前老夫曾对jxl可以说是倍加赞赏（当时老夫还为了它而写了一篇文章，详见&lt;a href=&#34;https://www.bridgeli.cn/archives/50&#34; title=&#34;JXL解析Excel常用方法&#34;&gt;这里&lt;/a&gt;），因为一直认为它虽然有bug，虽然兼容性不好，但是它简单易用啊，只要自己够仔细认真就能避开这些坑，但是从这周起，老夫决定jxl一生黑，因为随着时间的推移，现在Excel的版本越来越新，而jxl只支持2003之前的版本，可以说解析起来异常麻烦，而poi有Apache做保证，表现越来越好，使用起来其实也不是很复杂，所以老夫决定之后再次遇到解析Excel的只用poi。&lt;br&gt;
下面是老夫写的一个解析Excel的一个工具类，希望对大家有所帮助。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析Excel所需的类库的maven依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;poi&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;3.14&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;poi-ooxml&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;3.14&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;解析的具体方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

import java.io.FileInputStream;  
import java.util.Date;  
import java.util.HashMap;  
import java.util.LinkedList;  
import java.util.List;  
import java.util.Map;

import org.apache.commons.io.FilenameUtils;  
import org.apache.poi.hssf.usermodel.HSSFWorkbook;  
import org.apache.poi.ss.usermodel.Cell;  
import org.apache.poi.ss.usermodel.DataFormatter;  
import org.apache.poi.ss.usermodel.DateUtil;  
import org.apache.poi.ss.usermodel.Row;  
import org.apache.poi.ss.usermodel.Sheet;  
import org.apache.poi.ss.usermodel.Workbook;  
import org.apache.poi.xssf.usermodel.XSSFWorkbook;  
import org.junit.Test;

public class ExcelReader {

protected static final String dateTimeFmtPattern = &amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;;

protected static final String dateFmtPattern = &amp;#34;yyyy-MM-dd&amp;#34;;

protected static final DataFormatter formatter = new DataFormatter();

@Test  
public void testReader() throws Exception {  
List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; list = readExcel(&amp;#34;E:/test1.xls&amp;#34;);  
List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; list2 = readExcel(&amp;#34;E:/test1.xlsx&amp;#34;);  
}

/**  
* 读取excel文件（同时支持2003和2007格式）  
*  
* @param fileName  
* 文件名，绝对路径  
* @return list中的map的key是列的序号  
* @throws Exception  
* io异常等  
*/  
public static List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; readExcel(String fileName) throws Exception {  
FileInputStream fis = null;  
Workbook wb = null;  
List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; list = null;  
try {  
String extension = FilenameUtils.getExtension(fileName);

fis = new FileInputStream(fileName);  
list = read(fis, extension);

return list;

} finally {  
if (null != wb) {  
wb.close();  
}

if (null != fis) {  
fis.close();  
}  
}

}

/**  
* 读取excel文件（同时支持2003和2007格式）  
*  
* @param fis  
* 文件输入流  
* @param extension  
* 文件名扩展名: xls 或 xlsx 不区分大小写  
* @return list中的map的key是列的序号  
* @throws Exception  
* io异常等  
*/  
public static List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; read(FileInputStream fis, String extension) throws Exception {

Workbook wb = null;  
List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; list = null;  
try {

if (&amp;#34;xls&amp;#34;.equalsIgnoreCase(extension)) {  
wb = new HSSFWorkbook(fis);  
} else if (&amp;#34;xlsx&amp;#34;.equalsIgnoreCase(extension)) {  
wb = new XSSFWorkbook(fis);  
} else {  
throw new Exception(&amp;#34;file is not office excel&amp;#34;);  
}

list = readWorkbook(wb);

return list;

} finally {  
if (null != wb) {  
wb.close();  
}  
}

}

protected static List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; readWorkbook(Workbook wb) throws Exception {  
List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; list = new LinkedList&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;();

for (int k = 0; k &amp;lt; wb.getNumberOfSheets(); k++) {  
Sheet sheet = wb.getSheetAt(k);  
int rows = sheet.getPhysicalNumberOfRows();

for (int r = 0; r &amp;lt; rows; r++) {  
Row row = sheet.getRow(r);  
if (row == null) {  
continue;  
}  
Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();  
int cells = row.getPhysicalNumberOfCells();

for (int c = 0; c &amp;lt; cells; c++) {  
Cell cell = row.getCell(c);  
if (cell == null) {  
continue;  
}  
String value = getCellValue(cell);  
map.put(String.valueOf(cell.getColumnIndex() + 1), value);  
}  
list.add(map);  
}

}

return list;  
}

protected static String getCellValue(Cell cell) {  
String value = null;

switch (cell.getCellType()) {  
case Cell.CELL_TYPE_FORMULA: // 公式  
case Cell.CELL_TYPE_NUMERIC: // 数字

double doubleVal = cell.getNumericCellValue();  
short format = cell.getCellStyle().getDataFormat();  
String formatString = cell.getCellStyle().getDataFormatString();

if (format == 14 || format == 31 || format == 57 || format == 58 || (format &amp;gt;= 176 &amp;amp;&amp;amp; format &amp;lt;= 183)) {  
// 日期  
Date date = DateUtil.getJavaDate(doubleVal);  
value = formatDate(date, dateFmtPattern);  
} else if (format == 20 || format == 32 || (format &amp;gt;= 184 &amp;amp;&amp;amp; format &amp;lt;= 187)) {  
// 时间  
Date date = DateUtil.getJavaDate(doubleVal);  
value = formatDate(date, &amp;#34;HH:mm&amp;#34;);  
} else {  
value = String.valueOf(doubleVal);  
}

break;  
case Cell.CELL_TYPE_STRING: // 字符串  
value = cell.getStringCellValue();

break;  
case Cell.CELL_TYPE_BLANK: // 空白  
value = &amp;#34;&amp;#34;;  
break;  
case Cell.CELL_TYPE_BOOLEAN: // Boolean  
value = String.valueOf(cell.getBooleanCellValue());  
break;  
case Cell.CELL_TYPE_ERROR: // Error，返回错误码  
value = String.valueOf(cell.getErrorCellValue());  
break;  
default:  
value = &amp;#34;&amp;#34;;  
break;  
}  
return value;  
}

@SuppressWarnings(&amp;#34;deprecation&amp;#34;)  
private static String formatDate(Date d, String sdf) {  
String value = null;

if (d.getSeconds() == 0 &amp;amp;&amp;amp; d.getMinutes() == 0 &amp;amp;&amp;amp; d.getHours() == 0) {  
// value = DateTimeUtil.getFormatedDate(d, dateFmtPattern);  
} else {  
// value = DateTimeUtil.getFormatedDate(d, sdf);

}

return value;  
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这些第三方工具类的框架来说，老夫一直认为我们没有必要每次都自己去一步一步的写，只要写一次就够了，所以本文就是老夫的一个笔记而已，希望做到无论是老夫还是渎职今后只要需要解析Excel的时候，找到这里，把这里的方法copy出去，改吧改吧就能用了，另外本文也只牵涉到对Excel的解析而已，并没有生成的部分，一方面我在工作中解析多余生成，另一方面我相信大家只要会解析生成也一定不是大问题，网上资料这么多，所以就留给读者自己去探索了&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
