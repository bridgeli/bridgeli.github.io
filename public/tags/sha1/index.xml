<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SHA1 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/sha1/</link>
    <description>Recent content in SHA1 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 21 Dec 2014 14:53:22 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/sha1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据加密算法之MD5和SHA1</title>
      <link>http://localhost:1313/posts/2014-12-21-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B9%8Bmd5%E5%92%8Csha1/</link>
      <pubDate>Sun, 21 Dec 2014 14:53:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/2014-12-21-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B9%8Bmd5%E5%92%8Csha1/</guid>
      <description>&lt;p&gt;这个星期记录一下数据加密算法，记得刚开始学编程的时候就有一个疑问：我们的密码就这么放在数据库里面，多不安全啊，数据库管理员不是拿着数据想干嘛就干嘛吗？但是由于认知有限，一直没有解决这个问题，直到去年实习时，当时的项目经理Zack说，用户密码不能明文存放到数据，必须经过MD5加密，终于解决了这个问题。因为MD5的不可逆性，所以就算知道MD5码，只要你不是一些弱密码，一般情况下发生泄密的可能性是非常非常小的，几乎可以认为是绝对安全的，但MD5实现的实现却很简单，今天就记录一下实习时用到的一个MD5加密算法的一个实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Encryption {

    public static String MD5(String input) {
        StringBuffer hexString = null;
        try {
// 获得MD5摘要算法的 MessageDigest 对象  
            MessageDigest mdInst = MessageDigest.getInstance(&amp;#34;MD5&amp;#34;);
// 使用指定的字节更新摘要  
            mdInst.update(input.getBytes());
// 获得密文  
            byte[] md = mdInst.digest();
// 把密文转换成十六进制的字符串形式  
            hexString = new StringBuffer();
// 字节数组转换为 十六进制 数  
            for (int i = 0; i &amp;lt; md.length; i++) {
                String shaHex = Integer.toHexString(md[i] &amp;amp; 0xFF);
                if (shaHex.length() &amp;lt; 2) {
                    hexString.append(0);
                }
                hexString.append(shaHex);
            }

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return hexString.toString();
    }

    public static String SHA1(String decript) {
        StringBuffer hexString = null;
        try {
            MessageDigest digest = java.security.MessageDigest.getInstance(&amp;#34;SHA-1&amp;#34;);
            digest.update(decript.getBytes());
            byte messageDigest[] = digest.digest();
// Create Hex String  
            hexString = new StringBuffer();
// 字节数组转换为 十六进制 数  
            for (int i = 0; i &amp;lt; messageDigest.length; i++) {
                String shaHex = Integer.toHexString(messageDigest[i] &amp;amp; 0xFF);
                if (shaHex.length() &amp;lt; 2) {
                    hexString.append(0);
                }
                hexString.append(shaHex);
            }

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return hexString.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里面还有一个SHA1机密算法的实现，主要是在自学微信开发时，微信在接入验证的数据经过字典排序后SHA1加密，所以就顺便记录了一下，算是两个比较常用的加密算法吧，供大家参考。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
