<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>模板方法 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link>
    <description>Recent content in 模板方法 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 14 Dec 2014 15:33:31 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>设计模式综合运用之Excel导入</title>
      <link>http://localhost:1313/posts/2014-12-14-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E4%B9%8Bexcel%E5%AF%BC%E5%85%A5/</link>
      <pubDate>Sun, 14 Dec 2014 15:33:31 +0000</pubDate>
      <guid>http://localhost:1313/posts/2014-12-14-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E4%B9%8Bexcel%E5%AF%BC%E5%85%A5/</guid>
      <description>&lt;p&gt;学以致用，前几篇文章我们学了很多设计模式，今天我们就把这些模式综合运用一下，看看实际应用是怎么导入Excel的，（当然这里面没有用到侦听者模式）&lt;br&gt;
我们先看一下Excel的样子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bridgeli.cn/wp-content/uploads/2014/12/20141214232827.png&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; src=&#34;https://www.bridgeli.cn/wp-content/uploads/2014/12/20141214232827-300x107.png&#34; alt=&#34;20141214232827&#34; width=&#34;300&#34; height=&#34;107&#34; class=&#34;alignnone size-medium wp-image-125&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为是Excel的的解析，所以应该是前台上传的，我们应该有一个Servlet来接收前台传过来的数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package cn.bridgeli.demo.servlet;

import java.io.File;
import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import cn.bridgeli.demo.servce.Container;
import cn.bridgeli.demo.servce.ExcelParseStrategy;

public class ExcelParseServlet extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
//真正的情况下应该由前台传过来的，这里是模拟就写死了  
        File file = new File(&amp;#34;D:/Excel.xls&amp;#34;);

        String excelType = request.getParameter(&amp;#34;excelType&amp;#34;);

// 此处是策略模式，至于怎么实现，大家可以参考策略模式  
        Container container = new Container();
        ExcelParseStrategy excelParseStrategy = container.getStrategy(excelType);

        excelParseStrategy.parse(file);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面看ExcelParseStrategy接口，和具体策略的实现：&lt;/p&gt;</description>
    </item>
    <item>
      <title>设计模式之模板方法</title>
      <link>http://localhost:1313/posts/2014-12-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 07 Dec 2014 14:29:26 +0000</pubDate>
      <guid>http://localhost:1313/posts/2014-12-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;这一节记录一下模板方法，在学模板方法之前，要先学习一下什么是模板，模板其实就是一个例子，例如我们做市场调研时，调研人员会给我们一个表格，我们只需要回答一些答案即可，映射到我们的代码中就是这个样子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;aaaaaaaa  
bbbbbbbb  
cccccccc  
\***\*****  
dddddddd  
eeeeeeee  
########  
ffffffff  
gggggggg  
$$$$$$$$  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是我们第一次写的代码，但是我们在后来的coding中发现，这一段代码我们需要copy一份，只需要该其中的第四行、第七行、第十行就行了，其余的不需要做修改，如果我们copy过去，改一下这么做虽然可以完成，但我们想一想如果我们代码里面一万处这样的代码，难道要copy一万次？这么做是不是很冗余？这时候就需要我们的模板方法上场了，下面看一个我们在实际中的典型应用：JDBC操作数据库，所以我们下面先看一个操作数据库的实际例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package cn.bridgeli.demo.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import cn.bridgeli.demo.entity.User;
import cn.bridgeli.demo.util.DBUtil;

public class UserDao {

    public User getUserById(int userId) {
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        User user = null;
        String sql = &amp;#34;SELECT * FROM user WHERE id = ?&amp;#34;;

        try {
            conn = DBUtil.getConn();
            pstmt = DBUtil.getPstmt(conn, sql);
            pstmt.setInt(1, userId);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                user = new User();
//  
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            DBUtil.close(rs);
            DBUtil.close(pstmt);
            DBUtil.close(conn);
        }
        return user;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码经过我们分析，很明显就建行不一样：String SQL不一样，pStmt设置参数不一样，if（rs.next()）不一样，所以我们可以把它做成模板方法，下面我们就重构着一段代码。在重构这段代码之前有几个问题我们先要明确：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
