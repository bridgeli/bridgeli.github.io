<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DateTime on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/datetime/</link>
    <description>Recent content in DateTime on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 31 Mar 2018 11:28:34 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/datetime/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>介绍一个强大易用的日期和时间库：Joda-Time</title>
      <link>http://localhost:1313/posts/2018-03-31-%E7%BB%8D%E4%B8%80%E4%B8%AA%E5%BC%BA%E5%A4%A7%E6%98%93%E7%94%A8%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%BA%93joda-time/</link>
      <pubDate>Sat, 31 Mar 2018 11:28:34 +0000</pubDate>
      <guid>http://localhost:1313/posts/2018-03-31-%E7%BB%8D%E4%B8%80%E4%B8%AA%E5%BC%BA%E5%A4%A7%E6%98%93%E7%94%A8%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%BA%93joda-time/</guid>
      <description>&lt;p&gt;在 Java 中处理日期和时间是很常见的需求，基础的工具类就是我们熟悉的 Date 和 Calendar,之前我也曾经&lt;a href=&#34;https://www.bridgeli.cn/archives/181&#34;&gt;写过一篇文章利用这两个类&lt;/a&gt;，怎么处理时间，然而这些工具类的 api 使用并不是很方便和强大，于是就诞生了Joda-Time 这个专门处理日期时间的库。而且 Joda-Time 很优秀，用了他之后再也停不下来，其在 Java 8 出现前的很长时间内成为 Java 中日期时间处理的事实标准，用来弥补 JDK 的不足。项目中要想使用 Joda-Time 很简单，只需要引入依赖：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
&amp;lt;dependency&amp;gt;  
&amp;lt;groupId&amp;gt;joda-time&amp;lt;/groupId&amp;gt;  
&amp;lt;artifactId&amp;gt;joda-time&amp;lt;/artifactId&amp;gt;  
&amp;lt;version&amp;gt;2.9.9&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面说一些常用的例子，供平时参考&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建任意时间对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dateTime=new DateTime(2018, 03, 31, 16, 57,55);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建当前时间对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dateTime=new DateTime();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;格式化时间输出&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dateTime = new DateTime();  
System.out.println(dateTime.toString(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;));
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;解析文本格式时间&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTimeFormatter format = DateTimeFormat.forPattern(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;);  
DateTime dateTime = DateTime.parse(&amp;#34;2018-03-31 17:01:45&amp;#34;, format);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;在当前日期上加上 90 天并输出结果&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dateTime = new DateTime();  
System.out.println(dateTime.plusDays(90).toString(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;获取今天的开始时间&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime nowTime = new DateTime();  
DateTime startOfDay = nowTime.withTimeAtStartOfDay();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;获取今天的结束时间&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime nowTime = new DateTime();  
DateTime endOfDay = nowTime.millisOfDay().withMaximumValue();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;计算两个日期的相隔天数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime nowTime = new DateTime();  
DateTime futureTime = new DateTime(2019, 10, 1, 0, 0, 0);  
Int days = Days.daysBetween(nowTime, futureTime).getDays();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;本月的第一天和最后一天&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dateTime = new DateTime();  
DateTime firstDateTimeOfMonth = dateTime.dayOfMonth().withMinimumValue().withTimeAtStartOfDay();  
DateTime lastDateTimeOfMonth = dateTime.dayOfMonth().withMaximumValue().withTimeAtStartOfDay();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;上个月的第一天和最后一天&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dateTime = new DateTime();  
DateTime startDate = dateTime.plusMonths(-1).dayOfMonth().withMinimumValue().withTimeAtStartOfDay();  
DateTime endDate = dateTime.plusMonths(-1).dayOfMonth().withMaximumValue().millisOfDay().withMaximumValue();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;在每天的6:30处理一些东西&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dt=new DateTime().withHourOfDay(6).withMinuteOfHour(30).withSecondOfMinute(0);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;在每月的7号的6:30处理一些东西&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dt=new DateTime().withDayOfMonth(7).withHourOfDay(6).withMinuteOfHour(30).withSecondOfMinute(0);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;在每年的8月的7号的6:30处理一些东西&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dt=new DateTime().withMonthOfYear(8).withDayOfMonth(7).withHourOfDay(6).withMinuteOfHour(30).withSecondOfMinute(0);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;获取年终 月、日、时、分、秒、毫秒&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTime dt = new DateTime();  
//获取当前时间的年  
int year = dt.getYear();  
//获取当前时间的月  
int month = dt.getMonthOfYear();  
//获取当前时间是一年中的第几天  
int dayOfYear = dt.getDayOfYear();  
//获取一个月中的天  
int day = dt.getDayOfMonth();  
//获取一周中的周几  
int week = dt.getDayOfWeek();  
//一天中的第几小时(取整)  
int hour = dt.getHourOfDay();  
//获取星期年  
int weekOfyear = dt.getWeekyear();  
//当前时间的秒中的毫秒  
int ms = dt.getMillisOfSecond();  
//获取当前时间的秒  
int second = dt.getSecondOfDay();  
//获取当前时间的毫秒  
long millis = dt.getMillis();
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;判断时间跨度是否包含当前时间,某个时间&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
Interval interval = new Interval(new DateTime(2018, 1, 1, 0, 0, 0), new DateTime(2018, 3, 30, 0, 0, 0));  
System.out.println(interval.containsNow());  
boolean contained = interval.contains(new DateTime(&amp;#34;2012-03-01&amp;#34;));
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;与JDK互转换&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
//通过jdk时间对象构造  
Date date = new Date();  
DateTime dateTime = new DateTime(date); 

Calendar calendar = Calendar.getInstance();  
dateTime = new DateTime(calendar); 

// Joda-time 各种操作&amp;amp;#8230;..  
dateTime = dateTime.plusDays(1) // 增加天  
.plusYears(1)// 增加年  
.plusMonths(1)// 增加月  
.plusWeeks(1)// 增加星期  
.minusMillis(1)// 减分钟  
.minusHours(1)// 减小时  
.minusSeconds(1);// 减秒数 

// 计算完转换成jdk 对象  
Date date2 = dateTime.toDate();  
Calendar calendar2 = dateTime.toCalendar(Locale.CHINA);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;解析 CST 格式的时间字符串&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
DateTimeFormatter format = DateTimeFormat.forPattern(&amp;#34;EEE MMM dd HH:mm:ss zzz yyyy&amp;#34;);  
DateTime dateTime = DateTime.parse(&amp;#34;Fri Mar 30 00:00:00 CST 2018&amp;#34;, format);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然作为一个强大的 时间日期 处理工具类，他还有更多更强大的 API，可以参看：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
