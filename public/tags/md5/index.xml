<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>MD5 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/md5/</link>
    <description>Recent content in MD5 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 30 Sep 2019 06:59:19 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/md5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Apache Commons Codec — 加密与编码</title>
      <link>http://localhost:1313/posts/2019-09-30-apache-commons-codec-%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/</link>
      <pubDate>Mon, 30 Sep 2019 06:59:19 +0000</pubDate>
      <guid>http://localhost:1313/posts/2019-09-30-apache-commons-codec-%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/</guid>
      <description>&lt;p&gt;明天就是十一假期了，公司也没多大事，刷知乎，看到有人吐槽曾经的一个合作伙伴连 md5 都写不对，告诉对方写错了，对方顾头不顾腚的修，还是没修对，然后测了一下自己写的想亏写对了，不然又遗留 bug 了，不过看下面评论，有人提到 Apache Commons Codec 里面都已经写好了，看了一下确实，反正也无聊，也写不了大文章，写着玩玩。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先看自己手写的 md5 // 今后大家不要这么写了，太傻了&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;

import java.security.MessageDigest;  
import java.security.NoSuchAlgorithmException;

/**  
* Created by bridgeli on 2019/7/12.  
*/  
public class EncryptUtils {

private static Logger logger = LoggerFactory.getLogger(EncryptUtils.class);

private EncryptUtils() {  
}

public static String getMD5(String content) {

if (null == content) {  
return &amp;#34;&amp;#34;;  
}

MessageDigest messageDigest = null;  
try {  
messageDigest = MessageDigest.getInstance(&amp;#34;md5&amp;#34;);  
} catch (NoSuchAlgorithmException e) {  
logger.error(&amp;#34;md5 error&amp;#34;, e);  
}  
if (null == messageDigest) {  
return &amp;#34;&amp;#34;;  
}  
messageDigest.update(content.getBytes());  
byte[] bytes = messageDigest.digest();  
StringBuilder stringBuilder = new StringBuilder();  
for (byte b : bytes) {  
String str = Integer.toHexString(b &amp;amp; 0xFF);  
if (str.length() == 1) {  
stringBuilder.append(&amp;#34;0&amp;#34;);  
}  
stringBuilder.append(str);  
}  
String result = stringBuilder.toString();

return result;  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;借助别人写好的工具类实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先引入依赖&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据加密算法之MD5和SHA1</title>
      <link>http://localhost:1313/posts/2014-12-21-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B9%8Bmd5%E5%92%8Csha1/</link>
      <pubDate>Sun, 21 Dec 2014 14:53:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/2014-12-21-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B9%8Bmd5%E5%92%8Csha1/</guid>
      <description>&lt;p&gt;这个星期记录一下数据加密算法，记得刚开始学编程的时候就有一个疑问：我们的密码就这么放在数据库里面，多不安全啊，数据库管理员不是拿着数据想干嘛就干嘛吗？但是由于认知有限，一直没有解决这个问题，直到去年实习时，当时的项目经理Zack说，用户密码不能明文存放到数据，必须经过MD5加密，终于解决了这个问题。因为MD5的不可逆性，所以就算知道MD5码，只要你不是一些弱密码，一般情况下发生泄密的可能性是非常非常小的，几乎可以认为是绝对安全的，但MD5实现的实现却很简单，今天就记录一下实习时用到的一个MD5加密算法的一个实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Encryption {

    public static String MD5(String input) {
        StringBuffer hexString = null;
        try {
// 获得MD5摘要算法的 MessageDigest 对象  
            MessageDigest mdInst = MessageDigest.getInstance(&amp;#34;MD5&amp;#34;);
// 使用指定的字节更新摘要  
            mdInst.update(input.getBytes());
// 获得密文  
            byte[] md = mdInst.digest();
// 把密文转换成十六进制的字符串形式  
            hexString = new StringBuffer();
// 字节数组转换为 十六进制 数  
            for (int i = 0; i &amp;lt; md.length; i++) {
                String shaHex = Integer.toHexString(md[i] &amp;amp; 0xFF);
                if (shaHex.length() &amp;lt; 2) {
                    hexString.append(0);
                }
                hexString.append(shaHex);
            }

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return hexString.toString();
    }

    public static String SHA1(String decript) {
        StringBuffer hexString = null;
        try {
            MessageDigest digest = java.security.MessageDigest.getInstance(&amp;#34;SHA-1&amp;#34;);
            digest.update(decript.getBytes());
            byte messageDigest[] = digest.digest();
// Create Hex String  
            hexString = new StringBuffer();
// 字节数组转换为 十六进制 数  
            for (int i = 0; i &amp;lt; messageDigest.length; i++) {
                String shaHex = Integer.toHexString(messageDigest[i] &amp;amp; 0xFF);
                if (shaHex.length() &amp;lt; 2) {
                    hexString.append(0);
                }
                hexString.append(shaHex);
            }

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return hexString.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里面还有一个SHA1机密算法的实现，主要是在自学微信开发时，微信在接入验证的数据经过字典排序后SHA1加密，所以就顺便记录了一下，算是两个比较常用的加密算法吧，供大家参考。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
