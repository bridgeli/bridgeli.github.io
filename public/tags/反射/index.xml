<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>反射 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/%E5%8F%8D%E5%B0%84/</link>
    <description>Recent content in 反射 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 31 Oct 2021 03:24:36 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%8F%8D%E5%B0%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>神奇的 (a == (Integer) 1 &amp;&amp; a == (Integer) 2 &amp;&amp; a == (Integer) 3) = true</title>
      <link>http://localhost:1313/posts/2021-10-31-%E7%A5%9E%E5%A5%87%E7%9A%84-a-integer-1-a-integer-2-a-integer-3-true/</link>
      <pubDate>Sun, 31 Oct 2021 03:24:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/2021-10-31-%E7%A5%9E%E5%A5%87%E7%9A%84-a-integer-1-a-integer-2-a-integer-3-true/</guid>
      <description>&lt;p&gt;前一段时间看了一篇文章 (a == (Integer) 1 &amp;amp;&amp;amp; a == (Integer) 2 &amp;amp;&amp;amp; a == (Integer) 3) 是否可以为 true，当时第一反应怎么可能，谁知道再往下看，作者竟然给出来如下代码，一运行神奇的事出现了，真的为 true，代码如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

import java.lang.reflect.Field;

public class Magic {

public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {  
Class cache = Integer.class.getDeclaredClasses()[0];  
Field c = cache.getDeclaredField(&amp;#34;cache&amp;#34;);  
c.setAccessible(true);  
Integer[] array = (Integer[]) c.get(cache);  
// array[129] is 1  
array[130] = array[129];  
// Set 2 to be 1  
array[131] = array[129];  
// Set 3 to be 1  
Integer a = 1;  
if (a == (Integer) 1 &amp;amp;&amp;amp; a == (Integer) 2 &amp;amp;&amp;amp; a == (Integer) 3) {  
System.out.println(true);  
} else {  
System.out.println(false);  
}

}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为作者没有给出解释，所以就研究了一番，发现需要基础非常扎实才能写出这段代码，这段代码之所以为 true，要理解如下几个问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>反射的简单应用：解决微信开发中if-else过多的问题</title>
      <link>http://localhost:1313/posts/2014-09-15-%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E4%B8%ADif-else%E8%BF%87%E5%A4%9A%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 15 Sep 2014 14:44:38 +0000</pubDate>
      <guid>http://localhost:1313/posts/2014-09-15-%E5%8F%8D%E5%B0%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E4%B8%ADif-else%E8%BF%87%E5%A4%9A%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;前一段时间，闲着无聊玩微信开发，遇到一个问题：当关注者向公众号发送消息，请求一些服务时，由于是文本消息，所以当公众号拿到消息内容时，必须判断消息以什么打头，即：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
String content = requestMap.get(&amp;#34;Content&amp;#34;).trim();

if (&amp;#34;?&amp;#34;.equals(content) || &amp;#34;？&amp;#34;.equals(content)) {

    respContent = &amp;#34;您好，我是生活小助手，请根据提示，回复内容选择服务：nn1 回复“天气”获取天气帮助n2 回复“歌曲”获取歌曲帮助n3 回复“公交”获取歌曲帮助n4 回复“火车”获取歌曲帮助&amp;#34;;

} else if (content.startsWith(&amp;#34;歌曲&amp;#34;)) {

//TODO

} else if (content.startsWith(&amp;#34;天气&amp;#34;)) {

//TODO

} else if (content.startsWith(&amp;#34;物流&amp;#34;)) {

//TODO

} else if (content.startsWith(&amp;#34;公交&amp;#34;)) {

//TODO

} else if (content.startsWith(&amp;#34;火车&amp;#34;)) {

//TODO

} else {

    respContent = &amp;#34;亲，很抱歉，由于功能还不够完善，尚不能处理您回复的信息，请回复“？”显示主菜单，获取帮助，有此给您带来的不便，还请见谅！&amp;#34;;

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来判断何种服务，调用具体的接口来处理，当你的功能越来越完善时，会导致if-else越来越多，多的会自己都搞不清了，另外这个方法也会越来越大，显然不是非常符合面向对象的单一职责原则。那么有没用一个比较好的方法来解决这个问题呢？我曾经的项目经理Zack曾经说过，上天不会这么惩罚一个后期维护代码的人，所以答案是勘定有，今天老夫就给大家带来一个解决方法，需要说明的是：这不是老夫的原创，是老夫研究捷微源码的找到的方法，老夫在捷微方法的基础上做了一些修改，所以先感谢捷微，感谢捷微的开发人员。最后需要说明的是，这个方法也不是很完善，如果有人参考的话，老样子，请做具体修改，但逻辑老夫保证不会有错。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
@Override

public BaseMessage handleText(String content, String fromUsername, String toUsername) {

    String respContent = null;

    BaseMessage baseMessage = null;

    if (&amp;#34;?&amp;#34;.equals(content) || &amp;#34;？&amp;#34;.equals(content)) {

        respContent = &amp;#34;您好，我是生活小助手，请根据提示，回复内容选择服务：nn1 回复“天气”获取天气帮助n2 回复“歌曲”获取歌曲帮助n3 回复“公交”获取公交帮助n4 回复“火车”获取火车帮助&amp;#34;;

    } else {

        List&amp;lt;WeixinExpandconfigEntity&amp;gt; weixinExpandconfigEntities = new ArrayList&amp;lt;WeixinExpandconfigEntity&amp;gt;();

        boolean isFind = false;// 是否找到关键字信息

        for (WeixinExpandconfigEntity weixinExpandconfigEntity : weixinExpandconfigEntities) {

// 如果已经找到关键字并处理业务，结束循环。

            if (isFind) {

                break;// 如果找到结束循环

            }

            String[] keys = weixinExpandconfigEntity.getKeyword().split(&amp;#34;,&amp;#34;);

            for (String k : keys) {

                if (content.indexOf(k) != -1) {

                    String className = weixinExpandconfigEntity.getClassname();

                    String returnType = weixinExpandconfigEntity.getReturnType();

                    KeyService keyService = null;

                    try {

                        keyService = (KeyService) Class.forName(className).newInstance();

                        baseMessage = (BaseMessage) Class.forName(returnType).newInstance();

                    } catch (InstantiationException e) {

                        e.printStackTrace();

                    } catch (IllegalAccessException e) {

                        e.printStackTrace();

                    } catch (ClassNotFoundException e) {

                        e.printStackTrace();

                    }

                    keyService.excute(baseMessage, content.substring(2));

                    isFind = true;

                    break;

                }

            }

        }

    }

    if (baseMessage == null) {

        TextMessage textMessage = new TextMessage();

        textMessage.setContent(respContent);

        baseMessage = textMessage;

    }

    baseMessage.setToUserName(fromUsername);

    baseMessage.setFromUserName(toUsername);

    baseMessage.setCreateTime(new Date().getTime());

    baseMessage.setFuncFlag(0);

    return baseMessage;

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
