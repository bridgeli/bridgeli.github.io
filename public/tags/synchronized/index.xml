<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Synchronized on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/synchronized/</link>
    <description>Recent content in Synchronized on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 07 Feb 2021 07:06:13 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/synchronized/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用两个线程交替打印数字和字母</title>
      <link>http://localhost:1313/posts/2021-02-07-%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D/</link>
      <pubDate>Sun, 07 Feb 2021 07:06:13 +0000</pubDate>
      <guid>http://localhost:1313/posts/2021-02-07-%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D/</guid>
      <description>&lt;p&gt;前一段时间听马士兵老师讲课，讲到某公司的一个面试，两个线程，其中一个线程输出ABC，另一个线程输出123，如何控制两个线程交叉输出1A2B3C，由于本人多线程掌握的一直不是很好，所以听完这道题，个人感觉收获良多，这是一个学习笔记。这道题有多种解法，不过有些属于纯炫技，所以只记录常见的三种解法。首先看第一种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;park 和 unpark&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo;

import com.google.common.collect.Lists;

import java.util.List;  
import java.util.concurrent.locks.LockSupport;

/**  
* @author BridgeLi  
* @date 2021/2/6 16:14  
*/  
public class Thread_Communication_Park_Unpark {

static Thread t1 = null;  
static Thread t2 = null;

public static void main(String[] args) {

final List&amp;lt;Integer&amp;gt; integers = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7);  
final List&amp;lt;String&amp;gt; strings = Lists.newArrayList(&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;E&amp;#34;, &amp;#34;F&amp;#34;, &amp;#34;G&amp;#34;);

t1 = new Thread(() -&amp;gt; integers.forEach(item -&amp;gt; {  
System.out.print(item);  
LockSupport.unpark(t2);  
LockSupport.park();  
}), &amp;#34;t1&amp;#34;);

t2 = new Thread(() -&amp;gt; strings.forEach(item -&amp;gt; {  
LockSupport.park();  
System.out.print(item);  
LockSupport.unpark(t1);  
}), &amp;#34;t2&amp;#34;);

t1.start();  
t2.start();  
}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个是最简单的实现方法，LockSupport.park() 使当前线程阻塞，而 LockSupport.unpark() 则表示唤醒一个线程，所以他需要一个参数，表示你要唤醒哪个线程，很好理解，也比较简单。&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于synchronized用法的简单理解</title>
      <link>http://localhost:1313/posts/2017-05-14-%E5%85%B3%E4%BA%8Esynchronized%E7%94%A8%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 14 May 2017 09:20:14 +0000</pubDate>
      <guid>http://localhost:1313/posts/2017-05-14-%E5%85%B3%E4%BA%8Esynchronized%E7%94%A8%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;synchronized 关键字既可以用于声明方法，也可以用于声明代码块，他们之间有什么区别呢？下面让我们逐一测试一下。&lt;br&gt;
先看以第一个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package demo;

public class SynchronizedDemo1 {

public synchronized static void foo1() {  
}

public synchronized static void foo2() {  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，foo1 和 foo2 是类的两个静态方法。在不同的线程中，这两个方法的调用时互斥的，不仅是他们之间，任何两个不同的线程的调用也互斥。下面看第二个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package demo;

public class SynchronizedDemo2 {

public synchronized void foo3() {  
}

public synchronized void foo4() {  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，foo3 和 foo4 是类的两个成员方法，在多线程环境中，调用同一个对象的 foo3 或者 foo4 是互斥的，与上一个例子的差别在于，这是针对同一个对象的多线程方法调用互斥。下面再看最后一个例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package demo;

public class SynchronizedDemo3 {

public void foo5() {  
synchronized (this) {

}  
}

public void foo6() {  
synchronized (SynchronizedDemo3.class) {

}  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，synchronized 用来修饰代码块，需要注意的是：synchronized 后面会有一个参数，其实这个就是用于同步的锁所属的对象。在这个例子中 synchronized (this) 与 SynchronizedDemo2 中加 synchronized 的成员方法是互斥的，而 synchronized (SynchronizedDemo3.class) 与 SynchronizedDemo1 中加 synchronized 的静态方法是互斥的。synchronized 用于修饰代码块会更加灵活，因为除了前面的这个例子外，synchronized 后面的参数可以是任意对象。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
