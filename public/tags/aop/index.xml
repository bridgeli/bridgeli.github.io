<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AOP on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/aop/</link>
    <description>Recent content in AOP on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 15 Mar 2020 07:32:50 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/aop/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring AOP 实现自定义注解</title>
      <link>http://localhost:1313/posts/2020-03-15-spring-aop-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Sun, 15 Mar 2020 07:32:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/2020-03-15-spring-aop-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</guid>
      <description>&lt;p&gt;自工作后，除了一些小项目配置事务使用过 AOP，真正自己写 AOP 机会很少，另一方面在工作后还没有写过自定义注解，一直很好奇注解是怎么实现他想要的功能的，刚好做项目的时候，经常有人日志打得不够全，经常出现问题了，查日志的才发现忘记打了，所以趁此机会，搜了一些资料，用 AOP + 自定义注解，实现请求拦截，自定义打日志，玩一下这两个东西，以下是自己完的一个小例子，也供需要的同学参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注解如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo.annotation;

import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;

/**  
* @author bridgeli  
*/  
@Target(ElementType.METHOD)  
@Retention(RetentionPolicy.RUNTIME)  
public @interface MyLog {  
/**  
* 方法描述  
*  
* @return  
*/  
String desc() default &amp;#34;&amp;#34;;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;切面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.demo.annotation;

import cn.bridgeli.utils.AuthorizeUtil;  
import cn.bridgeli.entity.Principal;  
import lombok.extern.slf4j.Slf4j;  
import org.apache.commons.lang3.StringUtils;  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Pointcut;  
import org.springframework.stereotype.Component;

/**  
* @author bridgeli  
* 1. 这是一个切面类  
*/  
@Aspect  
@Component  
@Slf4j  
public class MyLogAspect {

/**  
* 2. PointCut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名  
* 切面最主要的就是切点，所有的故事都围绕切点发生  
* logPointCut()代表切点名称  
*/  
@Pointcut(&amp;#34;@annotation(cn.bridgeli.demo.annotation.MyLog)&amp;#34;)  
public void logPointCut() {  
}

/**  
* 3. 环绕通知  
*  
* @param joinPoint  
* @param myLog  
* @return  
*/  
@Around(value = &amp;#34;logPointCut() &amp;amp;&amp;amp; @annotation(myLog)&amp;#34;, argNames = &amp;#34;joinPoint,myLog&amp;#34;)  
public Object logAround(ProceedingJoinPoint joinPoint, MyLog myLog) {  
// 获取方法名  
String methodFullPathName = joinPoint.getTarget().getClass().getName() + &amp;#34;#&amp;#34; + joinPoint.getSignature().getName();

// 获取参数  
String params = StringUtils.join(joinPoint.getArgs(), &amp;#34;;&amp;#34;);

Principal currentUser = AuthorizeUtil.getCurrentUser();  
log.info(&amp;#34;当前登陆用户：&amp;#34; + (null == currentUser ? &amp;#34;&amp;#34; : currentUser.toString()) + &amp;#34;，进入 [ &amp;#34; + methodFullPathName + &amp;#34; ] 方法, 方法的描述：&amp;#34; + myLog.desc() + &amp;#34;，参数为:&amp;#34; + params);

// 继续执行方法  
long startTime = System.currentTimeMillis();  
Object result = null;  
try {  
result = joinPoint.proceed();  
} catch (Throwable e) {  
log.error(&amp;#34;切面执行报错，参数：&amp;#34; + params, e);  
}  
long elapsed = System.currentTimeMillis() &amp;amp;#8211; startTime;

log.info(&amp;#34;[ &amp;#34; + methodFullPathName + &amp;#34; ] 方法执行结束，返回值为：&amp;#34; + (null == result ? &amp;#34;&amp;#34; : result.toString()) + &amp;#34;，用时：&amp;#34; + elapsed);

return result;  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后只需要在想使用的地方 @MyLog 就可以了，当然也可以加上 @MyLog(desc = “这是方法描述”)，这样打出来的日志还会有方法是做什么的，别人看日志的时候能够一目了然。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring aop应用之实现数据库读写分离</title>
      <link>http://localhost:1313/posts/2016-12-31-spring-aop%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</link>
      <pubDate>Sat, 31 Dec 2016 12:12:51 +0000</pubDate>
      <guid>http://localhost:1313/posts/2016-12-31-spring-aop%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</guid>
      <description>&lt;p&gt;去年五月份的时候曾经写过一篇：&lt;a href=&#34;https://www.bridgeli.cn/archives/166&#34; title=&#34;Spring加Mybatis实现MySQL数据库主从读写分离&#34;&gt;Spring加Mybatis实现MySQL数据库主从读写分离&lt;/a&gt;，实现的原理是配置了多套数据源，相应的sqlsessionfactory，transactionmanager和事务代理各配置了一套，如果从库或数据库有多个的时候，需要配置的信息会越来越多，远远不够优雅，在我们编程界有一个规范：约定优于配置。所以就用Sping的aop实现了一个简单的数据库分离方案，具体实现代码放在了Github上，地址如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
https://github.com/bridgeli/practical-util/tree/master/src/main/java/cn/bridgeli/datasource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;读者如果想使用再简单的方法就是把这个代码download下来，放到自己的项目里面，当然更优雅的方式是：打成jar包，放到项目里面了，具体打jar的方法，老夫就不在这里多说了，相信看这篇文章的读者肯定都会了。当然仅仅有这份代码，他们是不会自动生效的，既然是使用Spring的Aop实现数据库读写分离，所以肯定会有牵涉到Aop的配置了，所以在spring-mybatis.xml中有如下配置：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;  
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34;  
xmlns:aop=&amp;#34;http://www.springframework.org/schema/aop&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34;  
xmlns:p=&amp;#34;http://www.springframework.org/schema/p&amp;#34; xmlns:tx=&amp;#34;http://www.springframework.org/schema/tx&amp;#34;  
xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;  
xsi:schemaLocation=&amp;#34;  
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd  
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd  
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&amp;#34;&amp;gt;

&amp;lt;!&amp;amp;#8211; 配置写数据源 &amp;amp;#8211;&amp;gt;  
&amp;lt;bean id=&amp;#34;masterDataSource&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;${bridgeli.jdbc.driver}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;${bridgeli.jdbc.url}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;${bridgeli.jdbc.username}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;${bridgeli.jdbc.password}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;validationQuery&amp;#34; value=&amp;#34;${bridgeli.jdbc.validationQuery}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;initialSize&amp;#34; value=&amp;#34;1&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;maxActive&amp;#34; value=&amp;#34;20&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;minIdle&amp;#34; value=&amp;#34;0&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;maxWait&amp;#34; value=&amp;#34;60000&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;testOnBorrow&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;testOnReturn&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;testWhileIdle&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;timeBetweenEvictionRunsMillis&amp;#34; value=&amp;#34;60000&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;minEvictableIdleTimeMillis&amp;#34; value=&amp;#34;25200000&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;removeAbandoned&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;removeAbandonedTimeout&amp;#34; value=&amp;#34;1800&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;logAbandoned&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;filters&amp;#34; value=&amp;#34;stat&amp;#34; /&amp;gt;  
&amp;lt;/bean&amp;gt;

&amp;lt;!&amp;amp;#8211; 配置读数据源 &amp;amp;#8211;&amp;gt;  
&amp;lt;bean id=&amp;#34;parentSlaveDataSource&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;${bridgeli.jdbc.driver}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;validationQuery&amp;#34; value=&amp;#34;${bridgeli.jdbc.validationQuery}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;initialSize&amp;#34; value=&amp;#34;1&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;maxActive&amp;#34; value=&amp;#34;20&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;minIdle&amp;#34; value=&amp;#34;0&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;maxWait&amp;#34; value=&amp;#34;60000&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;testOnBorrow&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;testOnReturn&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;testWhileIdle&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;timeBetweenEvictionRunsMillis&amp;#34; value=&amp;#34;60000&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;minEvictableIdleTimeMillis&amp;#34; value=&amp;#34;25200000&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;removeAbandoned&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;removeAbandonedTimeout&amp;#34; value=&amp;#34;1800&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;logAbandoned&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;filters&amp;#34; value=&amp;#34;stat&amp;#34; /&amp;gt;  
&amp;lt;/bean&amp;gt;  
&amp;lt;bean id=&amp;#34;slaveDataSource1&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34; parent=&amp;#34;parentSlaveDataSource&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;${bridgeli_slave1.jdbc.url}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;${bridgeli_slave1.jdbc.username}&amp;#34; /&amp;gt;  
&amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;${bridgeli_slave1.jdbc.password}&amp;#34; /&amp;gt;  
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;#34;dataSource&amp;#34; class=&amp;#34;cn.bridgeli.datasource.MasterSlaveDataSource&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;targetDataSources&amp;#34;&amp;gt;  
&amp;lt;map&amp;gt;  
&amp;lt;entry key-ref=&amp;#34;masterDataSource&amp;#34; value-ref=&amp;#34;masterDataSource&amp;#34;/&amp;gt;  
&amp;lt;entry key-ref=&amp;#34;slaveDataSource1&amp;#34; value-ref=&amp;#34;slaveDataSource1&amp;#34;/&amp;gt;  
&amp;lt;/map&amp;gt;  
&amp;lt;/property&amp;gt;  
&amp;lt;property name=&amp;#34;defaultTargetDataSource&amp;#34; ref=&amp;#34;masterDataSource&amp;#34;/&amp;gt;  
&amp;lt;property name=&amp;#34;masterSlaveSelector&amp;#34; ref=&amp;#34;dataSelector&amp;#34;/&amp;gt;  
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;#34;dataSelector&amp;#34; class=&amp;#34;cn.bridgeli.datasource.MasterSlaveSelectorByPoll&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;masters&amp;#34;&amp;gt;  
&amp;lt;list&amp;gt;  
&amp;lt;ref bean=&amp;#34;masterDataSource&amp;#34;/&amp;gt;  
&amp;lt;/list&amp;gt;  
&amp;lt;/property&amp;gt;  
&amp;lt;property name=&amp;#34;slaves&amp;#34;&amp;gt;  
&amp;lt;list&amp;gt;  
&amp;lt;ref bean=&amp;#34;slaveDataSource1&amp;#34;/&amp;gt;  
&amp;lt;/list&amp;gt;  
&amp;lt;/property&amp;gt;  
&amp;lt;property name=&amp;#34;defaultDataSource&amp;#34; ref=&amp;#34;masterDataSource&amp;#34;/&amp;gt;  
&amp;lt;/bean&amp;gt;

&amp;lt;aop:aspectj-autoproxy/&amp;gt;

&amp;lt;!&amp;amp;#8211; mybaits 数据工厂 &amp;amp;#8211;&amp;gt;  
&amp;lt;bean id=&amp;#34;sqlSessionFactory&amp;#34; class=&amp;#34;org.mybatis.spring.SqlSessionFactoryBean&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;dataSource&amp;#34; ref=&amp;#34;dataSource&amp;#34; /&amp;gt;  
&amp;lt;/bean&amp;gt;

&amp;lt;!&amp;amp;#8211; 自动扫描所有注解的路径 &amp;amp;#8211;&amp;gt;  
&amp;lt;bean class=&amp;#34;org.mybatis.spring.mapper.MapperScannerConfigurer&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;basePackage&amp;#34; value=&amp;#34;cn.bridgeli.mapper&amp;#34; /&amp;gt;  
&amp;lt;!&amp;amp;#8211; &amp;lt;property name=&amp;#34;sqlSessionFactory&amp;#34; ref=&amp;#34;sqlSessionFactory&amp;#34; /&amp;gt; &amp;amp;#8211;&amp;gt;  
&amp;lt;property name=&amp;#34;sqlSessionFactoryBeanName&amp;#34; value=&amp;#34;sqlSessionFactory&amp;#34;&amp;gt;&amp;lt;/property&amp;gt;  
&amp;lt;/bean&amp;gt;

&amp;lt;!&amp;amp;#8211; 数据库切面 &amp;amp;#8211;&amp;gt;  
&amp;lt;bean id=&amp;#34;masterSlaveAspect&amp;#34; class=&amp;#34;cn.bridgeli.datasource.MasterSlaveAspect&amp;#34;&amp;gt;  
&amp;lt;property name=&amp;#34;prefixMasters&amp;#34;&amp;gt;  
&amp;lt;list&amp;gt;  
&amp;lt;value&amp;gt;save&amp;lt;/value&amp;gt;  
&amp;lt;value&amp;gt;update&amp;lt;/value&amp;gt;  
&amp;lt;value&amp;gt;delete&amp;lt;/value&amp;gt;  
&amp;lt;/list&amp;gt;  
&amp;lt;/property&amp;gt;  
&amp;lt;/bean&amp;gt;  
&amp;lt;aop:config&amp;gt;  
&amp;lt;aop:aspect id=&amp;#34;c&amp;#34; ref=&amp;#34;masterSlaveAspect&amp;#34;&amp;gt;  
&amp;lt;aop:pointcut id=&amp;#34;tx&amp;#34; expression=&amp;#34;execution(\* cn.bridgeli.service..\*.*(..))&amp;#34;/&amp;gt;  
&amp;lt;aop:before pointcut-ref=&amp;#34;tx&amp;#34; method=&amp;#34;before&amp;#34;/&amp;gt;  
&amp;lt;/aop:aspect&amp;gt;  
&amp;lt;/aop:config&amp;gt;

&amp;lt;context:annotation-config /&amp;gt;  
&amp;lt;context:component-scan base-package=&amp;#34;cn.bridgeli&amp;#34; /&amp;gt;  
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们就很优雅的利用Spring的Aop实现了对数据库的读写分离，读的时候走slaveDataSource1这个数据源，写的时候走masterDataSource这个数据源。哎，等等，这里哪里体现了约定优于配置这一规范，他们怎么知道哪些方法走读库哪些走写库？同学你别急，仔细读读这个配置文件，你就会发现在第98行，配置了一个MasterSlaveAspect，也就是说代码里面service层（为什么是service层？）的方法以这里面配置的这些关键字打头，都将会走写库，所以当我们想让一个方法走主库的时候，必须在这个地方添加该方法的前缀或者用这里面已有的前缀，这就要求我们必须约定好走主库的方法的打头，即约定优于配置。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
