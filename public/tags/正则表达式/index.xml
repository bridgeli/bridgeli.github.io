<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>正则表达式 on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
    <description>Recent content in 正则表达式 on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 06 Apr 2015 14:16:10 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>正则表达式入门</title>
      <link>http://localhost:1313/posts/2015-04-06-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 06 Apr 2015 14:16:10 +0000</pubDate>
      <guid>http://localhost:1313/posts/2015-04-06-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;p&gt;今天讲讲正则表达式，正则表达式在编程中是非常常用的一项技术，也是非常行之有效的技术，有了他，很多复杂的问题就变得的非常简单了，常见的用途有：字符串匹配（或者叫字符匹配）、字符串查找、字符串替换，典型应用有：用户注册时用户名和密码的验证、检测IP地址是否正确，从网页中揪出链接等等，从常见用途中我们看到，一言以蔽之，正则表达式就是对字符串的处理，所以正则表达式牵涉到的类有三个：java.lang.String、java.util.regex.Pattern、java.util.regex.Matcher，其实正则的用途和功能非常强大，今天老夫就写一些最基本的用法，其实那些高级用法也是从这些基本用法来的，今后看看有没有机会写一下高级用法（主要是老夫现在也不会，，，），下面我们来看看这些最基本的语法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
[abc] a、b 或 c（简单类）  
[^abc] 任何字符，除了 a、b 或 c（否定）  
[a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围）  
[a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集）  
[a-z&amp;amp;&amp;amp;[def]] d、e 或 f（交集）  
[a-z&amp;amp;&amp;amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去）  
[a-z&amp;amp;&amp;amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去）
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;预定义字符类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
. 任何字符（与行结束符可能匹配也可能不匹配）  
d 数字：[0-9]  
D 非数字： [^0-9]  
s 空白字符：[ tnx0Bfr]  
S 非空白字符：[^s]  
w 单词字符：[a-zA-Z_0-9]  
W 非单词字符：[^w]
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;边界匹配器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
^ 行的开头  
$ 行的结尾  
b 单词边界  
B 非单词边界  
A 输入的开头  
G 上一个匹配的结尾  
Z 输入的结尾，仅用于最后的结束符（如果有的话）  
z 输入的结尾
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Greedy 数量词&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
X? X，一次或一次也没有  
X* X，零次或多次  
X+ X，一次或多次  
X{n} X，恰好 n 次  
X{n,} X，至少 n 次  
X{n,m} X，至少 n 次，但是不超过 m 次
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;反斜线、转义和引用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
反斜线字符 (&amp;amp;#8221;) 用于引用转义构造，如上表所定义的，同时还用于引用其他将被解释为非转义构造的字符。因此，表达式 \ 与单个反斜线匹配，而 { 与左括号匹配。

在不表示转义构造的任何字母字符前使用反斜线都是错误的；它们是为将来扩展正则表达式语言保留的。可以在非字母字符前使用反斜线，不管该字符是否非转义构造的一部分。

根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 &amp;#34;b&amp;#34; 与单个退格字符匹配，而 &amp;#34;\b&amp;#34; 与单词边界匹配。字符串字面值 &amp;#34;(hello)&amp;#34; 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 &amp;#34;\(hello\)&amp;#34;。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实正则表达式的用法说说难不难，但说简单一点也不简单，下面是一个例子对以上的这些语法进行测试，当我们想不起来的时候，可以把这些例子拷出来跑一下，看一下效果就知道了&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
