<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DFA on 分享技术带来的喜悦</title>
    <link>http://localhost:1313/tags/dfa/</link>
    <description>Recent content in DFA on 分享技术带来的喜悦</description>
    <generator>Hugo -- 0.156.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 02 May 2016 12:38:56 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/dfa/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DFA算法应用之敏感词过滤</title>
      <link>http://localhost:1313/posts/2016-05-02-dfa%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B9%8B%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/</link>
      <pubDate>Mon, 02 May 2016 12:38:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/2016-05-02-dfa%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B9%8B%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/</guid>
      <description>&lt;p&gt;公司在做一个社区应用，由于我朝特色，众所周知社区应用有一个很重要的就是要进行敏感词的过滤，这块由一个同事负责，听他说，有一个算法叫DFA，可以做这个，个人比较感兴趣，就到网上查了一些资料，有一篇文章写的特别好，老夫的这篇文章就是把其核心的部分（就是怎么应用，老夫一直有一个观点，理论弱于实践，理论懂得再多不会用一点用没有，所以老夫认为应用是核心）摘出来，留作笔记，如果有想了解其原理的，请点击下方的参考资料，好了，既然是应用那么就直接上代码了：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
package cn.bridgeli.dfa;

import java.util.HashSet;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;

public class SensitivewordFilter {  
@SuppressWarnings(&amp;#34;rawtypes&amp;#34;)  
private Map sensitiveWordMap = null;  
public static int minMatchTYpe = 1; // 最小匹配规则  
public static int maxMatchType = 2; // 最大匹配规则

/**  
* 初始化敏感词库  
*/  
public SensitivewordFilter() {  
sensitiveWordMap = new SensitiveWordInit().initKeyWord();  
}

/**  
* 判断文字是否包含敏感字符  
*  
* @param txt  
* 文字  
* @param matchType  
* 匹配规则 1：最小匹配规则，2：最大匹配规则  
* @return 若包含返回true，否则返回false  
*/  
public boolean isContaintSensitiveWord(String txt, int matchType) {  
boolean flag = false;  
for (int i = 0; i &amp;lt; txt.length(); i++) {  
int matchFlag = this.CheckSensitiveWord(txt, i, matchType); // 判断是否包含敏感字符  
if (matchFlag &amp;gt; 0) {  
flag = true;  
}  
}  
return flag;  
}

/**  
* 获取文字中的敏感词  
*  
* @param txt  
* 文字  
* @param matchType  
* 匹配规则&amp;amp;nbsp;1：最小匹配规则，2：最大匹配规则  
* @return  
*/  
public Set&amp;lt;String&amp;gt; getSensitiveWord(String txt, int matchType) {  
Set&amp;lt;String&amp;gt; sensitiveWordList = new HashSet&amp;lt;String&amp;gt;();

for (int i = 0; i &amp;lt; txt.length(); i++) {  
int length = CheckSensitiveWord(txt, i, matchType);  
if (length &amp;gt; 0) {  
sensitiveWordList.add(txt.substring(i, i + length));  
i = i + length &amp;amp;#8211; 1; // 减1的原因，是因为for会自增  
}  
}

return sensitiveWordList;  
}

/**  
* 替换敏感字字符  
*  
* @param txt  
* @param matchType  
* @param replaceChar  
\* 替换字符，默认\*  
*/  
public String replaceSensitiveWord(String txt, int matchType, String replaceChar) {  
String resultTxt = txt;  
Set&amp;lt;String&amp;gt; set = getSensitiveWord(txt, matchType); // 获取所有的敏感词  
Iterator&amp;lt;String&amp;gt; iterator = set.iterator();  
String word = null;  
String replaceString = null;  
while (iterator.hasNext()) {  
word = iterator.next();  
replaceString = getReplaceChars(replaceChar, word.length());  
resultTxt = resultTxt.replaceAll(word, replaceString);  
}

return resultTxt;  
}

/**  
* 获取替换字符串  
*  
* @param replaceChar  
* @param length  
* @return  
*/  
private String getReplaceChars(String replaceChar, int length) {  
String resultReplace = replaceChar;  
for (int i = 1; i &amp;lt; length; i++) {  
resultReplace += replaceChar;  
}

return resultReplace;  
}

/**  
* 检查文字中是否包含敏感字符，检查规则如下：&amp;lt;br&amp;gt;  
*  
* @param txt  
* @param beginIndex  
* @param matchType  
* @return，如果存在，则返回敏感词字符的长度，不存在返回0  
*/  
@SuppressWarnings({ &amp;#34;rawtypes&amp;#34; })  
public int CheckSensitiveWord(String txt, int beginIndex, int matchType) {  
boolean flag = false; // 敏感词结束标识位：用于敏感词只有1位的情况  
int matchFlag = 0; // 匹配标识数默认为0  
char word = 0;  
Map nowMap = sensitiveWordMap;  
for (int i = beginIndex; i &amp;lt; txt.length(); i++) {  
word = txt.charAt(i);  
nowMap = (Map) nowMap.get(word); // 获取指定key  
if (nowMap != null) { // 存在，则判断是否为最后一个  
matchFlag++; // 找到相应key，匹配标识+1  
if (&amp;#34;1&amp;#34;.equals(nowMap.get(&amp;#34;isEnd&amp;#34;))) { // 如果为最后一个匹配规则,结束循环，返回匹配标识数  
flag = true; // 结束标志位为true  
if (SensitivewordFilter.minMatchTYpe == matchType) { // 最小规则，直接返回,最大规则还需继续查找  
break;  
}  
}  
} else { // 不存在，直接返回  
break;  
}  
}  
if (matchFlag &amp;lt; 2 || !flag) { // 长度必须大于等于1，为词  
matchFlag = 0;  
}  
return matchFlag;  
}

public static void main(String[] args) {  
SensitivewordFilter filter = new SensitivewordFilter();  
System.out.println(&amp;#34;敏感词的数量：&amp;#34; + filter.sensitiveWordMap.size());  
String string = &amp;#34;太多的伤感情怀也许只局限于饲养基地 荧幕中的情节，主人公尝试着去用某种方式渐渐的很潇洒地释自杀指南怀那些自己经历的伤感。&amp;#34;  
+ &amp;#34;然后法轮功 我们的扮演的角色就是跟随着主人公的喜红客联盟 怒哀乐而过于牵强的把自己的情感也附加于银幕情节中，然后感动就流泪，&amp;#34;  
+ &amp;#34;难过就躺在某一个人的怀里尽情的阐述心扉或者手机卡复制器一个人一杯红酒一部电影在夜三级片 深人静的晚上，关上电话静静的发呆着。&amp;#34;;  
Set&amp;lt;String&amp;gt; set = filter.getSensitiveWord(string, 1);  
System.out.println(&amp;#34;语句中包含敏感词的个数为：&amp;#34; + set.size() + &amp;#34;。包含：&amp;#34; + set);  
}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个主要是应用，DFA的核心是下面：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
