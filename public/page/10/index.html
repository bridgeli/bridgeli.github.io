<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head>
	<meta name="generator" content="Hugo 0.156.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>分享技术带来的喜悦</title>
<meta name="keywords" content="博客, 技术, Java">
<meta name="description" content="技术分享博客">
<meta name="author" content="Bridge Li">
<link rel="canonical" href="http://localhost:1313/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css" integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="分享技术带来的喜悦 (Alt + H)">分享技术带来的喜悦</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java GC之垃圾回收算法
    </h2>
  </header>
  <div class="entry-content">
    <p>上一篇文章简单写了一下JVM如何判断一个对象是否已经死了，当判断出一个对象已经死了之后，接下来就要进行垃圾回收了，所以在进行垃圾回收之前，先让我们看看垃圾回收的算法有哪些。
标记-清除算法 标记清除见名知意该算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象，至于如何标记就是上一篇文章中所讲的方法了。这种算法比较简单，容易理解，同时也是一个最基础的垃圾回收算法，后面所讲的算法都是对他的改进，至于为什么需要改进，因为他主要存在两个不足：
①. 效率问题，标记和清除两个阶段的效率都不高；
②. 空间问题，标记清除之后会留下大量的不连续的内存碎片，内存碎片会导致当后面在程序的运行过程中可能需要给较大的对象分配空间时，无法找到足够的内存而不得不提前触发另一次垃圾回收。这种算法的执行过程如下图：
复制算法 复制算法为了解决标记清除算法的效率问题：它将内存分为容量大小相同的两块，每次只使用其中一块，当这一块的内存空间用完了，他就讲里面存活着的对象复制到另一块上面，然后再把已使用过的这一块内存空间一次性清理掉，这样使得每次都是对半个内存区域进行会回收，内存分配时也不用考虑空间碎片的问题，只需要移动指针，按顺序分配即可，实现简单，运行高效。但是他也有缺点：每次使用的内存空间只有整个空间的一半，这“浪费”有点高啊。复制算法的执行过程如下图：
不过现代的商业JVM都采用了这种算法来回收新生代，究其原因不仅仅他解决了效率问题，更是经研究表明：新生代中的对象高达98%都是“朝生夕死”的，所以这样一来就不需要1:1来划分空间了。直接将内存空间分为一块较大的Eden区和两块较小的Survivor区，每次使用Eden和其中一块Survivor区，当需要回收时，直接将Eden和Survivor中还存活的对象一次性的复制到另一块Survivor区，最后在清理Eden和刚使用过的Survivor。HotSpot虚拟机Eden和Survivor的大小比例默认为8:1，也就是每次使用的空间大小是90%，只“浪费”了10%。但是98%的对象回收也不能保证，每次存活的对象所使用的空间小于10%，所以当Survivor空间不够时，就需要其他空间（一般是老年代）进行分配担保，如果另一块Survivor空间没有足够的空间存放上一次新生代垃圾回收存活的对象时，这些对象将直接通过分配担保机制进入老年代。
标记-整理算法 复制算法适用于新生代的对象“朝生夕死”，如果一个区域内的对象老是不死，不仅内次都需要复制大量的对象，效率很低，而且还需要额外的空间进行担保（分配担保是一个很复杂的东西，今后有机会会说到），所以对于老年代的对象，这种算法是不适合的，于是就提出了标记-整理算法。
标记-整理算法和标记-清除算法一样，也是分两个阶段，而且第一个阶段也一样，都是标记，所不同的是第二个阶段，不是对可回收的对象进行直接清理，而是让还存活着的对象向一端移动，然后直接清理掉端边界以为的内存空间，该算法的执行过程如下图：
分代收集算法 当前的商业JVM都是采用的这种算法，其实这种算法并没有什么新思想，而是根据对象存活周期的不同将内存划分几块，一般是把Java堆分为两块：新生代和老年代，这样就可以根据各个代的不同特点采取最适当的垃圾收集算法。新生代的对象大多都是“朝生夕死”的，而且还可以有老年代进行担保，那就采用复制算法，只需要付出少量的存活对象的复制成本就可以完成收集，而且一般也不需要启用担保策略，而老年代的对象存活率一般比较高、没有空间进行担保，就只有采用“标记-清理”或者“标记-整理”算法来进行回收了。
参考资料：周志明《深入理解Java虚拟机》第二版第三章
</p>
  </div>
  <footer class="entry-footer"><span title='2017-02-19 14:07:54 +0000 +0000'>February 19, 2017</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>16 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Java GC之垃圾回收算法" href="http://localhost:1313/posts/2017-02-19-java-gc%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java GC之对象已死吗
    </h2>
  </header>
  <div class="entry-content">
    <p>差不多两年以前曾经写过一篇文章：JAVA 性能调优，其实在那篇文章中只是简单的说了，对象的分布。这篇文章继续对分布于堆中的对象的生命周期进行说明，也就是确定堆中的这些对象哪些还是“活着”的，哪些是已经“死去”（即不可能再被任何途径使用的对象）的。
引用计数算法 有很多人认为判断对象是否活着的算法是这样的：给对象添加一个引用计数器，每当有一个地方引用他的时候，计数器就加1，引用失效的时候，计数器减1，当计数器的数值为0时就是不可能在被引用的对象，此时就就可以认为是已死的对象。引用计数器算法实现简单，效率也很高，是一个不错的算法，但是主流的Java虚拟机并没有采用这种算法来管理内存，其中最主要的原因就是：它很难解决对象之间循环引用的问题。
举一个简单的例子：对象objA和objB都有字段instance，赋值令，除此之外，这两个对象再无任何引用，实际上他们已经不可能在被访问到，但是他们因为相互引用对方，计数器都不可能为0，计数器算法是无法通知GC收集器收集他们的。
package demo; /** * testGC()方法执行后，objA和objB会不会被GC呢？ * * @author BridgeLi * */ public class ReferenceCountingGC { public Object instance = null; private static final int _1MB = 1024 * 1024; // 这个成员的唯一意义就是占用内存，以便能在GC日志中看清楚是否被回收过 private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() { ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; // 假设发生了GC，看objA和objB是否能被回收 System.gc(); } public static void main(String[] args) { ReferenceCountingGC.testGC(); } } 从这个例子的运行结果来看，虚拟机并没有这两个对象存在相互引用就不收集他们，从而证明了Java虚拟机不是通过引用计数算法来判断对象是否已死的。
...</p>
  </div>
  <footer class="entry-footer"><span title='2017-02-11 13:58:44 +0000 +0000'>February 11, 2017</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>215 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Java GC之对象已死吗" href="http://localhost:1313/posts/2017-02-11-java-gc%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Redis实现分布式锁
    </h2>
  </header>
  <div class="entry-content">
    <p>大家都知道Redis是NoSQL的一种，目前在互联网公司中在作为缓存广泛的使用者，其实利用Redis的setnx还可以快速实现一个分布式锁，公司的业务就需要使用分布式锁保证数据的唯一性，经检索在网上发现已经有活雷锋分享了一套，本着不在重新发明轮子的想法，测试了一下好像没有问题，几乎不用对原代码进行修改，就能使用，下面就分享在这里，供需要的朋友参考。原文里面还有对实现的原理进行解释，所以本文就不再赘述，详情请通过参考资料进行访问。
package cn.bridgeli.distributedlock; import java.util.UUID; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.atomic.AtomicInteger; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; import redis.clients.jedis.Transaction; public class RedisDistributedLock { private static final Logger LOG = LoggerFactory.getLogger(RedisDistributedLock.class); private static final String redisHost = &#34;127.0.0.1&#34;; private static final int port = 6381; private static JedisPoolConfig config; private static JedisPool pool; private static ExecutorService service; private static int ThLeng = 10; private static CountDownLatch latch; private static AtomicInteger Countor = new AtomicInteger(0); private static int count = 0; private static String LockName = &#34;mylock_test10&#34;; static { // 利用Redis连接池，保证多个线程利用多个连接，充分模拟并发性 config = new JedisPoolConfig(); config.setMaxIdle(10); config.setMaxWaitMillis(1000); config.setMaxTotal(30); pool = new JedisPool(config, redisHost, port); // 利用ExecutorService 管理线程 service = Executors.newFixedThreadPool(ThLeng); // CountDownLatch保证主线程在全部线程结束之后退出 latch = new CountDownLatch(ThLeng); } /** * 获取锁 tips：生成一个UUID，作为Key的标识，不断轮询lockName，直到set成功，表示成功获取锁。 * 其他的线程在set此lockName时被阻塞直到超时。 * * @param pool * @param lockName * @param timeouts * @return 锁标志 */ public static String getLock(JedisPool pool, String lockName, long timeouts) { Jedis client = pool.getResource(); try { String value = UUID.randomUUID().toString(); long timeWait = System.currentTimeMillis() &#43; timeouts * 1000; while (System.currentTimeMillis() &lt; timeWait) { if (client.setnx(lockName, value) == 1) { // 防止key卡死，一直不释放锁，所以1800s过期 client.expire(lockName, 1800); LOG.info(&#34;lock geted&#34;); return value; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } LOG.info(&#34;get lock timeouts&#34;); } finally { // pool.returnBrokenResource(client); pool.returnResource(client); } return null; } /** * 释放锁 tips：对lockName做watch，开启一个事务，删除以LockName为key的锁，删除后，此锁对于其他线程为可争抢的。 * * @param pool * @param lockName * @param value */ public static void relaseLock(JedisPool pool, String lockName, String value) { Jedis client = pool.getResource(); try { while (true) { client.watch(lockName); if (client.get(lockName).equals(value)) { Transaction tx = client.multi(); tx.del(lockName); tx.exec(); return; } client.unwatch(); } } finally { // pool.returnBrokenResource(client); pool.returnResource(client); } } public static void main(String args[]) { for (int i = 0; i &lt; ThLeng; i&#43;&#43;) { String tName = &#34;thread-&#34; &#43; i; Thread t = new Thread(new SubAddThread(pool, tName)); LOG.info(tName &#43; &#34;inited&amp;#8230;&#34;); service.submit(t); } service.shutdown(); try { latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } LOG.info(Countor.get() &#43; &#34;&#34;); LOG.info(count &#43; &#34;&#34;); } public static class SubAddThread implements Runnable { private String name; private JedisPool pool; public SubAddThread(JedisPool pool, String uname) { this.pool = pool; this.name = uname; } @Override public void run() { for (int i = 0; i &lt; 100; i&#43;&#43;) { LOG.info(name &#43; &#34; starting&amp;#8230;&#34;); String valuse = getLock(pool, LockName, 50); LOG.info(name &#43; &#34; get Lock &#34; &#43; valuse); count&#43;&#43;; relaseLock(pool, LockName, valuse); Countor.incrementAndGet(); LOG.info(name &#43; &#34; &#34; &#43; count); } latch.countDown(); LOG.info(name &#43; &#34; complated&#34;); } } } 参考资料：http://www.jianshu.com/p/c1f5d26cb1c9
</p>
  </div>
  <footer class="entry-footer"><span title='2017-01-15 12:05:06 +0000 +0000'>January 15, 2017</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>401 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Redis实现分布式锁" href="http://localhost:1313/posts/2017-01-15-redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring aop应用之实现数据库读写分离
    </h2>
  </header>
  <div class="entry-content">
    <p>去年五月份的时候曾经写过一篇：Spring加Mybatis实现MySQL数据库主从读写分离，实现的原理是配置了多套数据源，相应的sqlsessionfactory，transactionmanager和事务代理各配置了一套，如果从库或数据库有多个的时候，需要配置的信息会越来越多，远远不够优雅，在我们编程界有一个规范：约定优于配置。所以就用Sping的aop实现了一个简单的数据库分离方案，具体实现代码放在了Github上，地址如下：
https://github.com/bridgeli/practical-util/tree/master/src/main/java/cn/bridgeli/datasource 读者如果想使用再简单的方法就是把这个代码download下来，放到自己的项目里面，当然更优雅的方式是：打成jar包，放到项目里面了，具体打jar的方法，老夫就不在这里多说了，相信看这篇文章的读者肯定都会了。当然仅仅有这份代码，他们是不会自动生效的，既然是使用Spring的Aop实现数据库读写分离，所以肯定会有牵涉到Aop的配置了，所以在spring-mybatis.xml中有如下配置：
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:aop=&#34;http://www.springframework.org/schema/aop&#34; xmlns:context=&#34;http://www.springframework.org/schema/context&#34; xmlns:p=&#34;http://www.springframework.org/schema/p&#34; xmlns:tx=&#34;http://www.springframework.org/schema/tx&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&#34;&gt; &lt;!&amp;#8211; 配置写数据源 &amp;#8211;&gt; &lt;bean id=&#34;masterDataSource&#34; class=&#34;com.alibaba.druid.pool.DruidDataSource&#34; destroy-method=&#34;close&#34;&gt; &lt;property name=&#34;driverClassName&#34; value=&#34;${bridgeli.jdbc.driver}&#34; /&gt; &lt;property name=&#34;url&#34; value=&#34;${bridgeli.jdbc.url}&#34; /&gt; &lt;property name=&#34;username&#34; value=&#34;${bridgeli.jdbc.username}&#34; /&gt; &lt;property name=&#34;password&#34; value=&#34;${bridgeli.jdbc.password}&#34; /&gt; &lt;property name=&#34;validationQuery&#34; value=&#34;${bridgeli.jdbc.validationQuery}&#34; /&gt; &lt;property name=&#34;initialSize&#34; value=&#34;1&#34; /&gt; &lt;property name=&#34;maxActive&#34; value=&#34;20&#34; /&gt; &lt;property name=&#34;minIdle&#34; value=&#34;0&#34; /&gt; &lt;property name=&#34;maxWait&#34; value=&#34;60000&#34; /&gt; &lt;property name=&#34;testOnBorrow&#34; value=&#34;false&#34; /&gt; &lt;property name=&#34;testOnReturn&#34; value=&#34;false&#34; /&gt; &lt;property name=&#34;testWhileIdle&#34; value=&#34;true&#34; /&gt; &lt;property name=&#34;timeBetweenEvictionRunsMillis&#34; value=&#34;60000&#34; /&gt; &lt;property name=&#34;minEvictableIdleTimeMillis&#34; value=&#34;25200000&#34; /&gt; &lt;property name=&#34;removeAbandoned&#34; value=&#34;true&#34; /&gt; &lt;property name=&#34;removeAbandonedTimeout&#34; value=&#34;1800&#34; /&gt; &lt;property name=&#34;logAbandoned&#34; value=&#34;true&#34; /&gt; &lt;property name=&#34;filters&#34; value=&#34;stat&#34; /&gt; &lt;/bean&gt; &lt;!&amp;#8211; 配置读数据源 &amp;#8211;&gt; &lt;bean id=&#34;parentSlaveDataSource&#34; class=&#34;com.alibaba.druid.pool.DruidDataSource&#34; destroy-method=&#34;close&#34;&gt; &lt;property name=&#34;driverClassName&#34; value=&#34;${bridgeli.jdbc.driver}&#34; /&gt; &lt;property name=&#34;validationQuery&#34; value=&#34;${bridgeli.jdbc.validationQuery}&#34; /&gt; &lt;property name=&#34;initialSize&#34; value=&#34;1&#34; /&gt; &lt;property name=&#34;maxActive&#34; value=&#34;20&#34; /&gt; &lt;property name=&#34;minIdle&#34; value=&#34;0&#34; /&gt; &lt;property name=&#34;maxWait&#34; value=&#34;60000&#34; /&gt; &lt;property name=&#34;testOnBorrow&#34; value=&#34;false&#34; /&gt; &lt;property name=&#34;testOnReturn&#34; value=&#34;false&#34; /&gt; &lt;property name=&#34;testWhileIdle&#34; value=&#34;true&#34; /&gt; &lt;property name=&#34;timeBetweenEvictionRunsMillis&#34; value=&#34;60000&#34; /&gt; &lt;property name=&#34;minEvictableIdleTimeMillis&#34; value=&#34;25200000&#34; /&gt; &lt;property name=&#34;removeAbandoned&#34; value=&#34;true&#34; /&gt; &lt;property name=&#34;removeAbandonedTimeout&#34; value=&#34;1800&#34; /&gt; &lt;property name=&#34;logAbandoned&#34; value=&#34;true&#34; /&gt; &lt;property name=&#34;filters&#34; value=&#34;stat&#34; /&gt; &lt;/bean&gt; &lt;bean id=&#34;slaveDataSource1&#34; class=&#34;com.alibaba.druid.pool.DruidDataSource&#34; destroy-method=&#34;close&#34; parent=&#34;parentSlaveDataSource&#34;&gt; &lt;property name=&#34;url&#34; value=&#34;${bridgeli_slave1.jdbc.url}&#34; /&gt; &lt;property name=&#34;username&#34; value=&#34;${bridgeli_slave1.jdbc.username}&#34; /&gt; &lt;property name=&#34;password&#34; value=&#34;${bridgeli_slave1.jdbc.password}&#34; /&gt; &lt;/bean&gt; &lt;bean id=&#34;dataSource&#34; class=&#34;cn.bridgeli.datasource.MasterSlaveDataSource&#34;&gt; &lt;property name=&#34;targetDataSources&#34;&gt; &lt;map&gt; &lt;entry key-ref=&#34;masterDataSource&#34; value-ref=&#34;masterDataSource&#34;/&gt; &lt;entry key-ref=&#34;slaveDataSource1&#34; value-ref=&#34;slaveDataSource1&#34;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&#34;defaultTargetDataSource&#34; ref=&#34;masterDataSource&#34;/&gt; &lt;property name=&#34;masterSlaveSelector&#34; ref=&#34;dataSelector&#34;/&gt; &lt;/bean&gt; &lt;bean id=&#34;dataSelector&#34; class=&#34;cn.bridgeli.datasource.MasterSlaveSelectorByPoll&#34;&gt; &lt;property name=&#34;masters&#34;&gt; &lt;list&gt; &lt;ref bean=&#34;masterDataSource&#34;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&#34;slaves&#34;&gt; &lt;list&gt; &lt;ref bean=&#34;slaveDataSource1&#34;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&#34;defaultDataSource&#34; ref=&#34;masterDataSource&#34;/&gt; &lt;/bean&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!&amp;#8211; mybaits 数据工厂 &amp;#8211;&gt; &lt;bean id=&#34;sqlSessionFactory&#34; class=&#34;org.mybatis.spring.SqlSessionFactoryBean&#34;&gt; &lt;property name=&#34;dataSource&#34; ref=&#34;dataSource&#34; /&gt; &lt;/bean&gt; &lt;!&amp;#8211; 自动扫描所有注解的路径 &amp;#8211;&gt; &lt;bean class=&#34;org.mybatis.spring.mapper.MapperScannerConfigurer&#34;&gt; &lt;property name=&#34;basePackage&#34; value=&#34;cn.bridgeli.mapper&#34; /&gt; &lt;!&amp;#8211; &lt;property name=&#34;sqlSessionFactory&#34; ref=&#34;sqlSessionFactory&#34; /&gt; &amp;#8211;&gt; &lt;property name=&#34;sqlSessionFactoryBeanName&#34; value=&#34;sqlSessionFactory&#34;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!&amp;#8211; 数据库切面 &amp;#8211;&gt; &lt;bean id=&#34;masterSlaveAspect&#34; class=&#34;cn.bridgeli.datasource.MasterSlaveAspect&#34;&gt; &lt;property name=&#34;prefixMasters&#34;&gt; &lt;list&gt; &lt;value&gt;save&lt;/value&gt; &lt;value&gt;update&lt;/value&gt; &lt;value&gt;delete&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:aspect id=&#34;c&#34; ref=&#34;masterSlaveAspect&#34;&gt; &lt;aop:pointcut id=&#34;tx&#34; expression=&#34;execution(\* cn.bridgeli.service..\*.*(..))&#34;/&gt; &lt;aop:before pointcut-ref=&#34;tx&#34; method=&#34;before&#34;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=&#34;cn.bridgeli&#34; /&gt; &lt;/beans&gt; 这样我们就很优雅的利用Spring的Aop实现了对数据库的读写分离，读的时候走slaveDataSource1这个数据源，写的时候走masterDataSource这个数据源。哎，等等，这里哪里体现了约定优于配置这一规范，他们怎么知道哪些方法走读库哪些走写库？同学你别急，仔细读读这个配置文件，你就会发现在第98行，配置了一个MasterSlaveAspect，也就是说代码里面service层（为什么是service层？）的方法以这里面配置的这些关键字打头，都将会走写库，所以当我们想让一个方法走主库的时候，必须在这个地方添加该方法的前缀或者用这里面已有的前缀，这就要求我们必须约定好走主库的方法的打头，即约定优于配置。
</p>
  </div>
  <footer class="entry-footer"><span title='2016-12-31 12:12:51 +0000 +0000'>December 31, 2016</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>297 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Spring aop应用之实现数据库读写分离" href="http://localhost:1313/posts/2016-12-31-spring-aop%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Blowfish加密算法Java版简单实现
    </h2>
  </header>
  <div class="entry-content">
    <p>前几天网上突然出现流言：某东发生数据泄露12G，最终某东在一篇声明中没有否认，还算是勉强承认了吧，这件事对于一般人有什么影响、应该怎么做已经有一堆人说了，所以就不凑热闹了，咱来点对程序猿来说实际点的，说一个个人认为目前比较安全的加密算法：Blowfish。
上代码之前，先说几点Blowfish加密算法的特点：
对称加密，即加密的密钥和解密的密钥是相同的； 每次加密之后的结果是不同的（这也是老夫比较欣赏的一点）； 可逆的，和老夫之前的文章介绍的md5等摘要算法不一样，他是可逆的； 速度快，加密和解密的过程基本上由ADD和XOR指令运算组成； 免费，任何人都可以免费使用不需要缴纳版权费； BlowFish 每次只能加密和解密8字节数据； 接下来就是最重要的部分，Blowfish加密算法的实现：
package cn.bridgeli.encrypt; public enum BlowfishManager { BRIDGELI_CN(&#34;bridgeli_cn!@#$abc123_&#34;); private BlowfishManager(String secret) { this.blowfish = new Blowfish(secret); } private Blowfish blowfish; public Blowfish getBlowfish() { return blowfish; } /** * 解密 * @param sCipherText * @return */ public String decryptString(String sCipherText){ return this.getBlowfish().decryptString(sCipherText); } /** * 加密 * @param sPlainText * @return */ public String encryptString(String sPlainText){ return this.getBlowfish().encryptString(sPlainText); } public static void main(String[] args) { String encryptString = BlowfishManager.BRIDGELI_CN.encryptString(10 &#43; &#34;&#34;); System.out.println(encryptString); String decryptString = BlowfishManager.BRIDGELI_CN.decryptString(encryptString); System.out.println(decryptString); } } 这是对外的接口，使用起来非常简单，对用户很友好，下面是算法的具体实现：
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-12-18 12:04:43 +0000 +0000'>December 18, 2016</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>3241 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Blowfish加密算法Java版简单实现" href="http://localhost:1313/posts/2016-12-18-blowfish%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95java%E7%89%88%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Dubbo服务telnet调试法
    </h2>
  </header>
  <div class="entry-content">
    <p>公司的RPC的服务使用的是阿里巴巴的dubbo，老夫之前曾经写过一篇如何在测试环境远程调试dubbo服务，详情请参考这篇，但一直对如何调试线上dubbo服务不得法，不得已每次都需要写一个web服务调一下看数据，前一段时间经新来的一个同事提示可以使用Telnet调试，网上搜了一下资料，发现真的很爽，以下是学习笔记。
需要说明的是：Dubbo2.0.5以上版本服务提供端口支持telnet命令，不过应该没有公司使用2.0.5以下版本吧。
进入调试模式 telnet localhost 20880 即：telnet &#43; ip &#43; 端口，这个不用解释，使用dubbo的肯定都知道
ls 使用上一个命令之后，敲一下回车，就进入dubbo的telnet调试服务了，然后就可以使用ls命令了，这个命令有几个用法：
①. 显示服务列表
ls ②. 显示服务详细信息列表
ls -l ③. 显示服务的方法列表
ls XxxService ④. 显示服务的方法详细信息列表
ls -l XxxService ps 这个命令主要是看连接信息，也有如下几个用法：
①. 显示服务端口列表
ps ②. 显示服务地址列表
ps -l ③. 显示端口上的连接信息
ps 20880 ④, 显示端口上的连接详细信息
ps -l 20880 cd 这个缺省服务，主要有以下两个用法：
①. 改变缺省服务，当设置了缺省服务，凡是需要输入服务名作为参数的命令，都可以省略服务参数
cd XxxService ②. 取消缺省服务
cd / pwd 显示当前缺省服务
trace 这个命令顾名思义：跟踪，具体有以下用法：
①. 跟踪1次服务任意方法的调用情况
trace XxxService ②. 跟踪10次服务任意方法的调用情况
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-11-27 13:12:26 +0000 +0000'>November 27, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>164 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Dubbo服务telnet调试法" href="http://localhost:1313/posts/2016-11-27-dubbo%E6%9C%8D%E5%8A%A1telnet%E8%B0%83%E8%AF%95%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">VIM常用命令
    </h2>
  </header>
  <div class="entry-content">
    <p>上个周苹果公司悍然发布了新版mac，消灭了功能键，包括ESC，终于使下面这个段子成为了事实：问，如何生成一段随机数？答：让一个非开发人员退出vim。哈哈，现在开发人员是不是也可以产生随机字符串了？发现自己作为一个vim党，竟然对很多vim常用的命令都不知道，今天就记一下笔记，让自己这个vim党称呼实至名归。
首先要说明的是，基本的vim命令像A、I、O进入编辑模式，ESC进入命令模式，“:”进入末行模式，以及常用的什么dd，yy，p等都认为大家已经熟练掌握，就不说了。
替换字符 :%s/oldchar/newchar/g 这个命令同样可以解决：
注1. 在windows记事本下的文件放到Linux下时，行末多出来一个^M，这个问题，直接把oldchar换成\r，newchar传承空就可以了。
注2. 在windows记事本下的文件放到Linux下时，行末多出来一个^@，这个问题，直接把oldchar换成先摁ctrl&#43;v，然后摁ctrl&#43;2，newchar传承空就可以了。
注3. 在windows记事本下的文件放到Linux下时，行末多出来一个^A，这个问题，直接把oldchar换成先摁ctrl&#43;v，然后摁ctrl&#43;A，newchar传承空就可以了。
注4. oldchar也可以用正则表达式，之前一直不知道怎么在每一行的行末加东西，其实如此简单而已。
加密文件 进入末行模式，然后输入大写的X，然后输入密码，保存退出即可，这样的话今后每次打开都需要输入密码才行，否则就是一堆乱码。
undo和redo 这个比较简单，undo直接摁u，redo是ctrl&#43;r
简单的移动光标 0 数字零，到行头 ^ 到本行第一个不是blank字符的位置 $ 到本行行尾 g_ 到本行最后一个不是blank字符的位置 /pattern 搜索 pattern 的字符串,如果搜索出多个匹配，可按n键到下一个 . (小数点) 可以重复上一次的命令 N&lt;command&gt; 重复某个命令N次 :N 到第N行 gg 到第一行。（陈皓注：相当于1G，或 :1） G 到最后一行 块操作: ctrl-v 块操作，典型的操作： 0、ctrl-v、ctrl-d、I、ESC
^ 到行头 ctrl-v 开始块操作 ctrl-d 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I 插入，然后输入 ESC 来为每一行生效。 自动提示 在输入模式下，你可以输入一个词的开头，然后按 ctrl-p或是ctrl-n，自动补齐功能就出现了
可视化选择： v,V,ctrl-v ctrl-v，我们可以使用 v 和 V。一但被选好了，你可以做下面的事： J 把所有的行连接起来（变成一行） &lt; 或 &gt; 左右缩进 = 自动给缩进 窗口分屏浏览 :He 在下边分屏浏览目录 :He! 在上分屏浏览目录 :Ve 在左边分屏间浏览目录 :Ve! 要在右边则是 多页签（tab page） 在末行模式下，输入：
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-11-06 13:05:15 +0000 +0000'>November 6, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>144 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to VIM常用命令" href="http://localhost:1313/posts/2016-11-06-vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">我看拉勾一拍之系统架构
    </h2>
  </header>
  <div class="entry-content">
    <p>今年年中的时候由公司平台部转组到Alpha项目中心负责公司一拍项目组的技术研发工作，到现在已经快有将近半年的时间了，随着对系统的越来越熟悉，对原有系统的架构也越来越感到有些不合理的地方，随着自己水平的提升感觉对架构也有了一点自己的理解，所以今天就借这个机会说说自己的不成熟的建议。
一. 原有的架构
俗话说，一图胜千言，直接上图：
解释一下这几个系统分别的作用：
后台管理系统不用说了，管理C和B可见的内容； C端用户系统，是对C可见的一个系统，一拍是一个招聘系统，所以就是对候选人操作的后台； B端用户系统，是对B可见的一个系统，通俗点讲就是HR操作的后台； Dubbo系统，是对兄弟部门和B提供服务的一个系统； Recommend系统，其实也是一个Dubbo系统，区别在于Dubbo系统是对外提供各种服务的，而Recommend系统是发现全站系统用户的行为，然后对用户的行为进行分析，甄选出一部分C端用户作为一拍的现在用户； msgpush系统，是用netty做的一个实时消息推送的IM服务，目前主要是给后台管理用户和C端候选人聊天的一个系统； 其中：1. 在我们接手之前B和C是同一个系统，也就是说B是我们这半年新加的一个系统；2. Recommend和msgpush系统也同样是我们这半年新增的一个系统
二. 系统架构存在的问题
目前后台管理系统、C端用户系统、Dubbo系统各自独立，这样存在的问题：
最主要的是各自分别操作数据库，这样只要底层数据库发送变动，那么三个系统操作数据库的地方都要同步修改三次；
操作数据库的地方代码冗余，很多地方都一样，这样一个地方出bug，三个地方要同步修改，然后都要上线；
后台管理系统采用分层的模式分模块而不是根据业务分模块，这样每次上线service和dao都要先deploy jar到maven私服；
当时为了快速迭代，Recommend系统也是单独操作操作数据库，不过还好用了后台管理系统的dao这个jar包，但是首先根本不需要这么重的一个jar包，其次jar出bug了，有时候他也需要重新上线啊，不然这个jar包就会一直很旧，当然只要不涉及到他操作数据库的地方出bug，你不改也是可以的；
目前C和B虽然已经分开，但如果用户激增，横向扩展依然不合理，只能整体加机器，而不能针对性对某些模块单独加机器；
代码中存在的问题：不知道什么原因大量的逻辑被写在了controller层，导致代码可复用性差；
由于之前后台管理系统和其他系统不是同一个团队开发的，命名各有各的风格，代码不仅冗余还同样一个类名字不一样；
很多系统日志配置的也有问题，错误日志和最基本的业务日志没有区分开，目前在将就用；
系统中的jar依赖不仅存在循环依赖，而且加入了大量的自己不需要的依赖，导致各种jar冲突出问题；
综合以上问题，我个人认为这是一个：可维护性、可扩展性不高的系统。
三. 我的个人思考
同样先来一张图，来总体说明一下我的想法：
整体来说只有相对独立的实时消息推送系统不懂，然后把其余的各个业务层抽象成微服务，采用公司目前使用比较成熟的dubbo作为rpc框架，controller层只负责业务转发不负责逻辑的一个简单系统，这样带来的好处：
Dubbo系统作为核心的业务系统，分别对兄弟部门、后台管理系统、C端用户系统、B端用户系统、Recommend系统提供服务，如果用户量增加，不仅可以整体增加Dubbo系统的机器，也可以把调用量大的接口单独拆出来，部署到另外的机器上，实现隔离，不会因某个接口调用量大，导致整个系统不可用，而且把数据库的底层操作也放到了这个Dubbo系统中，这样就可以避免数据库修改，要修改多处的问题； 抽象出来的这个dubbo系统，不仅可以解决后台系统和其他系统命名不一样的问题，而且和可以解决不同团队造成的coding style不一的问题，一举多得； 由于后台管理系统、C端用户系统、B端用户系统、Recommend系统都调用Dubbo系统，所以他们的controller层讲极其简单，很多业务逻辑类似的东西全部放到了Dubbo系统里面，代码的可复用性提高了不少； 抽象出来的逻辑都统一放到了dubbo中，这样系统如果有bug，这样就做到了一个地方修改，这样多个地方就可以同时生效； 由于业务都在Dubbo系统里面这样同时也避免了曾经出现了，后台管理系统和BC系统使用的缓存不一致，导致缓存出问题的这种低级bug； 由于controller层简单没有逻辑，这样就可以避免目前由于后台管理系统单机，修改一个业务逻辑bug重启系统，导致后台不可用的问题，因为只需要重启dubbo就行了； 这样controller层变得很轻，只需要一个简单的servlet容器，对机器的要求会降低不少； 四. 备注
由于我工作时间不长，见过的系统更有限，所以对系统架构几乎没有什么经验，这些只是我个人的一点很粗浅的理解，例如把dubbo做的那么重，虽然可扩展性提高了不少，但其实也不知道算不算合理，因为调用rpc服务，肯定会增加网络IO延时，所以这些算是我个人的抛砖引玉吧，一方面希望对同样和我一样没有经验的小伙伴能有所帮助，另一方面希望有经验的小伙伴能留言交流
五. 总结
以上便是我个人对拉勾一拍所有的核心系统进行了审视后的一番分析，如果这些核心系统架构的重构真的达到自己的理想状况这将是一番浩大的工程，对于高速发展的互联网公司来说，这就是一边驾驶者一辆高速前进的汽车，一边对这辆汽车进行换轮胎换发动机，先不说工作量的问题，难度程度也可见一斑。
</p>
  </div>
  <footer class="entry-footer"><span title='2016-10-23 13:57:34 +0000 +0000'>October 23, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>46 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to 我看拉勾一拍之系统架构" href="http://localhost:1313/posts/2016-10-23-%E6%88%91%E7%9C%8B%E6%8B%89%E5%8B%BE%E4%B8%80%E6%8B%8D%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Redis 3.0入门二之集群搭建和使用
    </h2>
  </header>
  <div class="entry-content">
    <p>上一篇文章讲了redis的主从搭建，主从一般只能解决我们读写分离的问题，可以增加我们的系统的负载能力，但是并不能解决单点问题，大家应该知道在互联网公司各个服务肯定不能出现单点问题，所以这一节就记录一下如果让我们的系统更加高可用。
一、集群搭建
需要先说明的是，集群搭建需要至少6个节点：3主3从(因为没有那么多机器，所以就在一台上搞了)
创建文件夹redis-cluster，然后在其下面分别创建6个文件夹，存放6个实例 mkdir -p /usr/local/redis-cluster mkdir 7001;mkdir 7002;mkdir 7003;mkdir 7004;mkdir 7005;mkdir 7006 把之前redis.conf配置文件分别copy到700*下，修改各个实例的配置文件的内容，如下： ①. daemonize yes ②. port 700*（一台机器端口号肯定不能相同，就和文件夹一样吧） ③. bind ip（和当前机器的ip地址绑定） ④. dir /usr/local/redis-cluster/700*/（文件存储位置应该不一样吧，原因都知道） ⑤. cluster-enabled yes ⑥. cluster-config-flie nodes-700\*.conf（700\*就和端口一样吧） ⑦. cluster-node-timeout 5000 ⑧. appendonly yes 安装ruby yum install ruby yum install rubygems gem install redis 启动各个实例 /usr/local/redis/bin/redis-server /usr/local/redis-cluster/700*/redis.conf 创建集群 cd /usr/local/redis-3.0.0-rc2/src ./redis-trib.rb create &amp;#8211;replicas 1 ip:7001 ip:7002 ip:7003 ip:7004 ip:7005 ip:7006 然后看输出日志，会有一步需要输入yes，然后集群就创建完成了
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-09-16 21:47:04 +0000 +0000'>September 16, 2016</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>274 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Redis 3.0入门二之集群搭建和使用" href="http://localhost:1313/posts/2016-09-16-redis-3-0%E5%85%A5%E9%97%A8%E4%BA%8C%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Redis 3.0入门一之主从搭建
    </h2>
  </header>
  <div class="entry-content">
    <p>周末没事看北京尚学堂之前的公开课视频，发现了白贺翔老师有一节课讲redis 3.0的视频教程，还不错，以下是学习笔记。
一、单机版搭建
首先是下载地址：http://redis.io/download，假设我们下载是redis-3.0.0-rc2.tar.gz
安装步骤：
把我们下载好的redis-3.0.0-rc2.tar.gz放到Linux的/usr/local文件夹下 解压tar -xzvf redis-3.0.0-rc2.tar.gz -C /usr/local/ 进入到redis-3.0.0-rc2目录下，进项make 进入到src下进行安装make install，验证（ll查看发现src下的目录，有redis-server、redis-cli即可） 建立两个文件夹存放redis命令和配置文件 mkdir -p /usr/local/redis/etc mkdir -p /usr/local/redis/bin 把redis-3.0.0-rc2下的redis.conf移动到/usr/local/redis/etc下 mv redis.conf /usr/local/redis/etc 把redis-3.0.0-rc2/src里的mkreleasehdr.sh、redis-benchmark、redis-check-aof、redis-check-dump、redis-cli、redis-server文件移动到bin下，命令 mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin 启动并指定配置文件 /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf 退出改为后台启动 退出就不说了，改为后台启动，编辑 /usr/local/redis/etc/redis.conf找到
daemonize no 改为
daemonize yes 修改持久化文件存放的位置，修改 dir ./ 为
dir /usr/local/redis/data/ redis客户端的使用 /usr/local/redis/binredis-cli -h host -p port 设置密码 通过刚才的操作应该可以发现redis默认是没有密码的，这样很不安全，设置密码的方法是编辑/usr/local/redis/etc/redis.conf找到requirepass 这一行，设置
requirepass bridgeli 这样通过客户端进入的时候加一个参数 -a 跟上你的密码就好了
...</p>
  </div>
  <footer class="entry-footer"><span title='2016-08-28 21:40:02 +0000 +0000'>August 28, 2016</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>138 words</span>&nbsp;·&nbsp;<span>Bridge Li</span></footer>
  <a class="entry-link" aria-label="post link to Redis 3.0入门一之主从搭建" href="http://localhost:1313/posts/2016-08-28-redis-3-0%E5%85%A5%E9%97%A8%E4%B8%80%E4%B9%8B%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/page/9/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/page/11/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">分享技术带来的喜悦</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
