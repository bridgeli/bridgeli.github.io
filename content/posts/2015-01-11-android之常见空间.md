---
title: Android之常见控件
author: Bridge Li
type: post
date: 2015-01-11T14:41:30+00:00

duoshuo_thread_id:
  - 1.1604454626757E+18
categories:
  - Android
tags:
  - 常见控件
---
在我们开发Android的时候，有各种各样常见的控件供我们使用，今天就记录一下这些常见的控件有哪些，其实他们的用法大多一样，希望能举一反三，  
第一个常见的控件恐怕就是EditText、TextView、Button，使用的例子如下：  
activity_main.xml布局文件：  
```  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical" >

<EditText
android:id="@+id/factorOne"
android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        />

<TextView
android:id="@+id/symbol"
android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        />
<EditText
android:id="@+id/factorTwo"
android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        />
<Button
android:id="@+id/calc"
android:layout_width="fill_parent"
        android:layout_height="wrap_content" />
        </LinearLayout>  
```  
对应的activity：  
```  
package cn.bridgeli.demo;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

public class MainActivity extends Activity {

    private EditText factorOne = null;
    private TextView symbol = null;
    private EditText factorTwo = null;
    private Button calc = null;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        factorOne = (EditText) findViewById(R.id.factorOne);
        symbol = (TextView) findViewById(R.id.symbol);
        factorTwo = (EditText) findViewById(R.id.factorTwo);
        calc = (Button) findViewById(R.id.calc);

        symbol.setText(R.string.symbol);
        calc.setText(R.string.calc);

        calc.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View arg0) {
                String firstNum = factorOne.getText().toString();
                String secondNum = factorTwo.getText().toString();

                Intent intent = new Intent();
                intent.setClass(MainActivity.this, ResultActivity.class);
                intent.putExtra("firstNum", firstNum);
                intent.putExtra("secondNum", secondNum);
                startActivity(intent);
            }
        });
    }

}
```  
result.xml布局文件就比较简单了，只有一个TextView  
```  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical" >

<TextView
android:id="@+id/result"
android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        />
        </LinearLayout>  
```  
同样第二个activity也比较简单，接收第一个activity传来的参数，进行计算，并展示出来：  
```  
package cn.bridgeli.demo;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.widget.TextView;

public class ResultActivity extends Activity{

    private TextView result = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.result);

        Intent intent = getIntent();
        int firstNum = Integer.parseInt(intent.getStringExtra("firstNum"));
        int secondNum = Integer.parseInt(intent.getStringExtra("secondNum"));

        result = (TextView) findViewById(R.id.result);

        int i = firstNum * secondNum;
        result.setText(i + "");
    }
} 
```

接下来我们看看另外的常见控件单选按钮Radio和复选按钮checkBox：  
同样布局文件：  
```  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
xmlns:tools="http://schemas.android.com/tools"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
android:orientation="vertical" >

<RadioGroup  
android:id="@+id/genderGroup"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
>  
<RadioButton  
android:id="@+id/femaleButton"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
android:text="@string/female"/>

<RadioButton  
android:id="@+id/maleButton"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
android:text="@string/male"/>

</RadioGroup>

<CheckBox  
android:id="@+id/swimButton"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
android:text=""  
/>  
<CheckBox  
android:id="@+id/runButton"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
android:text=""  
/>  
<CheckBox  
android:id="@+id/readButton"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
android:text=""  
/>  
</LinearLayout>  
```

记着Radio有一个组的概念，对应的activity就比较简单了  
```  
package cn.bridgeli.demo;

import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.Toast;

public class MainActivity extends ActionBarActivity {

    private RadioGroup radioGroup = null;
    private RadioButton female = null;
    private RadioButton male = null;

    private CheckBox swimButton = null;
    private CheckBox runButton = null;
    private CheckBox readButton = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        radioGroup = (RadioGroup) findViewById(R.id.genderGroup);
        female = (RadioButton) findViewById(R.id.femaleButton);
        male = (RadioButton) findViewById(R.id.maleButton);

        radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {

            @Override
            public void onCheckedChanged(RadioGroup group, int checkId) {
                if(female.getId() == checkId){
                    Toast.makeText(MainActivity.this, "female", Toast.LENGTH_SHORT).show();
                }else if(male.getId() == checkId){
                    Toast.makeText(MainActivity.this, "male", Toast.LENGTH_SHORT).show();
                }
            }
        });

        swimButton = (CheckBox) findViewById(R.id.swimButton);
        runButton = (CheckBox) findViewById(R.id.runButton);
        readButton = (CheckBox) findViewById(R.id.readButton);

        swimButton.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {

            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) {
                if(isChecked){
                    System.out.println("swim is checked");
                }else{
                    System.out.println("swim is unchecked");
                }
            }
        });
    }

}  
```  
其实就是找到他们，并为他们设置监听器而已，这其中有一个控件是Toast，这个控件其实在我们开发的时候用途是非常大的，例如：用户填写表单时的数据验证，提示用户；我们的应用需要网路，而用户没有联网时，提示用户联网；还有我们最最常见的提示用户连点两次back键时，退出应用。  
下面在让我们看看Android中的另外几个控件进度条，首先是普通的进度条：  
```  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
xmlns:tools="http://schemas.android.com/tools"  
android:layout_width="match_parent"  
android:layout_height="match_parent"  
android:orientation="vertical" >

<ProgressBar  
android:id="@+id/firstBar"  
style="?android:attr/progressBarStyleHorizontal"  
android:layout_width="wrap_content"  
android:layout_height="wrap_content"  
android:visibility="gone"/>

<ProgressBar  
android:id="@+id/secondBar"  
style="?android:attr/progressBarStyle"  
android:layout_width="wrap_content"  
android:layout_height="wrap_content"  
android:visibility="gone"/>

<Button  
android:id="@+id/begin"  
android:layout_width="wrap_content"  
android:layout_height="wrap_content"/>  
</LinearLayout>  
```  
对应的activity:  
```  
package cn.bridgeli.demo3;

import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.RatingBar;
import android.widget.RatingBar.OnRatingBarChangeListener;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;

public class MainActivity extends ActionBarActivity {

    private ProgressBar firstBar = null;
    private ProgressBar secondBar = null;
    private Button begin = null;

    int i = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        firstBar = (ProgressBar) findViewById(R.id.firstBar);
        secondBar = (ProgressBar) findViewById(R.id.secondBar);

        begin = (Button) findViewById(R.id.begin);
        begin.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View view) {
                if(0 == i){
                    firstBar.setVisibility(View.VISIBLE);
                    secondBar.setVisibility(View.VISIBLE);
                }else if(i <= 100){
                    firstBar.setProgress(i);
                    firstBar.setSecondaryProgress(i+10);
                    secondBar.setProgress(i);
                }else{
                    firstBar.setVisibility(View.GONE);
                    secondBar.setVisibility(View.GONE);
                }
            }

        });

    }

}
```

接下来还有两个比较常见的进度条：SeekBar和RatingBar，他们的用法也很简单，首先来看SeekBar：  
```  
seekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

    @Override
    public void onStopTrackingTouch (SeekBar seekBar){

    }

    @Override
    public void onStartTrackingTouch (SeekBar seekBar){

    }

    @Override
    public void onProgressChanged (SeekBar seekBar,int progress, boolean fromUser){

    }
});  
```  
这个bar最大的特点就是用户可以自己手动拖动调整当前进度，其常见于视频、音频播放器的进度表示，接下来我们再看看另一个RatingBar，  
```  
ratingBar.setNumStars(5);  
ratingBar.setStepSize((float) 0.5);

        ratingBar.setOnRatingBarChangeListener(new OnRatingBarChangeListener() {

    @Override
    public void onRatingChanged(RatingBar ratingBar, float progress, boolean fromUser) {

    }
}); 
```  
这个bar和其他几个bar明显不同，它的特别非常明显，以星星的形式展示，我们可以自己决定星星的个数以及步长，这个应用也比较多，相信大家已经想到了：打分，当让用户评价一个东西是，我们可以让用户选择给几颗星，那么这个时候这个bar就派上用场了。

其实Android中有很多常见的控件供我们使用，他们大多也不难，就是在布局文件中设置一下（当然也可以在activity中设置），然后我们的activity中给他们设置监听器，重写监听器中的方法仅此而已，相信大家看了此文，自己动手做几个小实验，就会明白这些控件怎么用了，同时也希望大家能举一反三，根据网上的资料当遇到其他常见控件的时候能灵活运用!

PS：第一次写Android的东西，既是初学还是自学，也没做过项目，所以不免有错误的地方和有点抓不住重点，还请大家能留言交流，谢谢