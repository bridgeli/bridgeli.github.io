---
title: 分享 Guava 的一些常见方法
author: Bridge Li
type: post
date: 2019-04-30T07:06:25+00:00

categories:
  - Java
tags:
  - Guava
---
前几天同事分享了一些关于 Guava 的一起基础用法，我之前没用过，感觉挺好的，所以记一些常见的方法。

一. 基础工具类，字符串相关的

其实这些在 apache commons-lang3，算是重复造轮子吧，简单说一下。

1. 判断字符串是否为空，之前看到很多人自己定义，这些可能是一些老程序员吧，apache commons-lang3，Guava 的如下：

```

boolean nullOrEmpty = Strings.isNullOrEmpty("");

```

2. 补全字符串(在前面补全和后面补全)

```

String padStart0 = Strings.padStart("3", 2, &#8216;a&#8217;);  
System.out.println("padStart0 = " + padStart0);

String padStart1 = Strings.padStart("333", 2, &#8216;a&#8217;);  
System.out.println("padStart1 = " + padStart1);

```

3. 拆分和合并字符串

```

List<String> list = Splitter.on(",").splitToList("Denny,BridgeLi,CCC");  
System.out.println("list = " + list);

String join = Joiner.on(",").join(list);  
System.out.println("join = " + join);

```

4. 对象相等判断和 ToStringHelper 类

```

boolean equal = Objects.equal("", "");  
MoreObjects.toStringHelper(); 

```

二. 集合类相关的，这些个人感觉还是非常常用的

1. 不可变集合

```

@Test  
public void testJDK() {  
List<String> list = new ArrayList<>();  
list.add("BridgeLi");  
list.add("DennyLi");

List<String> unmodifiableList = Collections.unmodifiableList(list);  
System.out.println(unmodifiableList);

unmodifiableList.add("Blog");  
System.out.println(unmodifiableList);  
list.add("Blog");  
System.out.println(unmodifiableList);

}

@Test  
public void testImmutableList() {  
List<String> list = new ArrayList<>();  
list.add("BridgeLi");  
list.add("DennyLi");

List<String> unmodifiableList = ImmutableList.copyOf(list);  
System.out.println(unmodifiableList);

unmodifiableList.add("Blog");  
System.out.println(unmodifiableList);  
list.add("Blog");  
System.out.println(unmodifiableList);

}

```

2. 可重复集合，这个其实很常用可重复 set 可以用来基数，而可重复 Map 则可以实现 Map<K, List<V>> 或者 Map<K, Set<V>> 这样比较复杂的集合类型的数据结构

```

@Test  
public void testMultiset() {  
List<String> strings = Lists.newArrayList("aa", "bb", "aa", "cc");

Multiset<String> wordsMultiset = HashMultiset.create();  
wordsMultiset.addAll(strings);

for (String key : wordsMultiset.elementSet()) {  
System.out.println(key + " count：" + wordsMultiset.count(key));  
}  
}

@Test  
public void teststuScoreMultimap() {  
Multimap<String, StudentScore> scoreMultimap = ArrayListMultimap.create();  
StudentScore studentScore = null;  
for (int i = 10; i < 20; i++) {  
studentScore = new StudentScore();  
studentScore.courseId = 1001 + i;  
studentScore.score = 100 &#8211; i;  
scoreMultimap.put("peida", studentScore);  
}  
System.out.println("scoreMultimap:" + scoreMultimap.size());  
System.out.println("scoreMultimap:" + scoreMultimap.keys());

Collection<StudentScore> studentScores = scoreMultimap.get("peida");  
StudentScore studentScore1 = new StudentScore();  
studentScore1.courseId = 1034;  
studentScore1.score = 67;  
studentScores.add(studentScore1);

StudentScore studentScore2 = new StudentScore();  
studentScore2.courseId = 1045;  
studentScore2.score = 56;  
scoreMultimap.put("jerry", studentScore2);

System.out.println("scoreMultimap:" + scoreMultimap.size());  
System.out.println("scoreMultimap:" + scoreMultimap.keys());

for (StudentScore stuScore : scoreMultimap.values()) {  
System.out.println("stuScore one:" + stuScore.courseId + " score:" + stuScore.score);  
}

scoreMultimap.remove("jerry", studentScore2);  
System.out.println("scoreMultimap:" + scoreMultimap.size());  
System.out.println("scoreMultimap:" + scoreMultimap.get("jerry"));

scoreMultimap.put("harry", studentScore2);  
scoreMultimap.removeAll("harry");  
System.out.println("scoreMultimap:" + scoreMultimap.size());  
System.out.println("scoreMultimap:" + scoreMultimap.get("harry"));  
}

class StudentScore{  
int courseId;  
int score;  
}

```

3. 双向 Map(BiMap)，Map 是一种键值对映射，这个映射是键到值的映射，而 BiMap 既提供键到值的映射，也提供值到键的映射，所以它是双向 Map

```

@Test  
public void testBimap() {  
BiMap<String, String> biMap = HashBiMap.create();  
biMap.put("星期一", "Monday");  
System.out.println("by key:" + biMap.get("星期一"));  
BiMap<String, String> biMap1 = biMap.inverse();  
System.out.println("biMap1:" + biMap1.get("Monday"));  
}

```

4. 双键 Map(Table)，有些时候需要写 Map<String, Map<String, String>> 这种格式的代码。但是这种阅读起来非常的不友好，Table 提供了新的思路：通过 rowKey + columnKey + value 来支持

```

@Test  
public void testTable() {  
Table<String, String, String> table = HashBasedTable.create();  
table.put("IBM", "101", "A");  
table.put("IBM", "102", "B");  
table.put("IBM", "103", "C");

table.put("sun", "111", "D");  
table.put("sun", "112", "E");  
table.put("sun", "113", "F");

table.put("Google", "121", "G");  
table.put("Google", "102", "H");  
table.put("Google", "123", "L");

System.out.println(table.get("IBM", "102"));  
System.out.println(table.row("IBM"));  
System.out.println(table.column("102"));  
}

```

部分参考：https://www.cnblogs.com/peida/tag/Guava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/