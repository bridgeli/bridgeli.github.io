---
title: Activity之生命周期
author: Bridge Li
type: post
date: 2015-01-04T15:08:13+00:00

duoshuo_thread_id:
  - 1.1604454626757E+18
categories:
  - Android
tags:
  - activity
  - life cycle

---
这几天没事，自学了一下Android的开发，今天记录一下activity的生命周期，在写之前，我们先看一下，Google官方的文档，窃以为这个说的已经比较清楚明白了：  
[<img loading="lazy" decoding="async" src="https://www.bridgeli.cn/wp-content/uploads/2015/01/activity_lifecycle-232x300.png" alt="activity_lifecycle" width="232" height="300" class="alignnone size-medium wp-image-133" />][1]  
从这张图，我们清楚无误的看到，activity的生命周期方法执行顺序为：onCreate()&#8211;>onStart()&#8211;>onResume()&#8211;>onPause()&#8211;>onStop()&#8211;>onRestart()&#8211;>ondestory()  
但是口说无凭，我们从一个例子中说明问题：  
第一个activity：  
```  
package cn.bridgeli.lifecycle;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {

    private Button button = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        button = (Button) findViewById(R.id.button);
        ButtonListener buttonListener = new ButtonListener();
        button.setOnClickListener(buttonListener);

        System.out.println("First activity onCreate");
    }

    class ButtonListener implements OnClickListener{

        @Override
        public void onClick(View arg0) {
            Intent intent = new Intent();
            intent.setClass(MainActivity.this, SecondActivity.class);
            startActivity(intent);
        }

    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        System.out.println("First activity onDestroy");
    }

    @Override
    protected void onPause() {
        System.out.println("First activity onPause");
        super.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
        System.out.println("First activity onResume");
    }

    @Override
    protected void onStart() {
        super.onStart();
        System.out.println("First activity onStart");
    }

    @Override
    protected void onStop() {
        super.onStop();
        System.out.println("First activity onStop");
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        System.out.println("First activity onRestart");
    }

}
```  
第二个activity：  
```  
package cn.bridgeli.lifecycle;

import android.app.Activity;
import android.os.Bundle;

public class SecondActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        System.out.println("second activity created");
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        System.out.println("second activity onDestroy");
    }

    @Override
    protected void onPause() {
        super.onPause();
        System.out.println("second activity onPause");
    }

    @Override
    protected void onResume() {
        super.onResume();
        System.out.println("second activity onResume");
    }

    @Override
    protected void onStart() {
        super.onStart();
        System.out.println("second activity onStart");
    }

    @Override
    protected void onStop() {
        super.onStop();
        System.out.println("second activity onStop");
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        System.out.println("second activity onRestart");
    }

}  
```  
当我们在手机里面运行时，从打印输出的语句里面很清晰的看到，他们的执行顺序，但是他们分别是什么时机执行的，在这些方法里面个要做些什么事呢？  
onCreate()方法是第一个要执行的方法，这个方法里面一般是用来设置布局文件，findViewByID()，并绑定事件；  
onStart()方法在onCreate()方法执行结束之后执行；  
onResume()方法是在activity完全显示出来，即可以或得焦点的时候执行；  
到了这个时候，我们的activity可以说是终于露出了庐山真面目；

这个时候如果我们点击页面上的button，onPause()方法便开始执行了，这个方法一般用于保存当前activity现场（即数据），例如我们此时用一个电话打进来了，我们就需要保存数据，以供接完电话后恢复现场，然后进入接电话的activity，接下来要执行的逻辑就和第一个activity相同了，即先onCreate()，然后onStart()，最后onResume()；  
如果大家按照我写的代码而执行的话，大家会发现，第二个activity的onResume()执行完之后，会执行第一个activity的onStop()方法，这就是onStop()执行的时机：当第二个activity把第一个activity完全遮盖之后会执行此方法；  
此时如果我们点back按钮，紧接着就会执行先执行第二个activity的onPause()，再然后就是第一个activity的onRestart()方法和onStart()以及onResume()方法。

到了此处，也许大家会发现onDesrory()方法并没有被执行啊，是的，相信大家一看这个方法的名字就知道了：onDestory()方法是在activity被销毁的时候执行，他执行的时机有两个：一是我们在activity中显式调用finish()方法，而是手机内存不足时，操作系统进行内存回收，那么此时该方法就会被调用了。

下面我们在深入看一下：onStop()方法，刚才我说了该方法调用的时机是第二个activity把第一个activity完全遮盖之后执行的，所以我们可以在Mainifest.xml中给第二个activity加一个标签：

```  
android:theme="@android:style/Theme.Dialog"  
```

我们就会发现此时第二个activity会以一个对话框的方式弹出来，并不会把第一个activity给完全覆盖掉，此时onStop()方法便不会执行，我想这也许也是在onPanse()保存现场的原因之一吧。

PS：第一次写Android的东西，既是初学还是自学，不免有错误的地方，还请大家能留言交流，谢谢

 [1]: https://www.bridgeli.cn/wp-content/uploads/2015/01/activity_lifecycle.png