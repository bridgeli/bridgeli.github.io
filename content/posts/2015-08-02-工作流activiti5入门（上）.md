---
title: 工作流Activiti5入门（上）
author: Bridge Li
type: post
date: 2015-08-02T14:28:34+00:00

duoshuo_thread_id:
  - 1.1604454626757E+18
categories:
  - 工作流
tags:
  - Java
  - workflow

---
刚工作的时候曾经用Activiti5，但由于当时介于水平，对Activiti5并没有很深的理解，而且知识也没有形成一个体系，前一段时间偶然发现传智播客公布了一个关于Activiti5的教学视频，自己跟着看了一下，感觉有很多收获，所以打算写几篇博文，整理一下，以供将来如有需要的话可以查阅，今天记下学习的前一部分，称为Activiti5上。

一. Activiti5开发环境搭建和配置

1. 开发环境搭建

Activiti5开发一个工作流系统，首先肯定是要搭建环境的，关于搭建环境老夫窃以为这篇文章：http://www.zhengmenbb.com/archives/98.htm，写的很不错，这篇文章不仅写了怎么搭建环境，还有一个小小的例子，大家可以先看一下，看了这篇文章，我相信大家搭建好环境不是问题，因为就是装一个插件而已，很简单。

2. 配置

现在的任何框架几乎都要和spring相整合，否则几乎可以说是玩不转，所以我们的Activiti5要想流行起来也不能例外，下面我们先看看他们怎么整合的。  
spring的整合肯定要引入spring的jar包，这个老夫默认大家都会了，如果不会的话，我相信也不会看到这篇文章，至于Activiti5要引入那些jar文件，可以参考这个

(1). 部分pom文件

```

<dependency>  
<groupId>org.activiti</groupId>  
<artifactId>activiti-engine</artifactId>  
<version>5.11</version>  
</dependency>  
<dependency>  
<groupId>org.activiti</groupId>  
<artifactId>activiti-spring</artifactId>  
<version>5.11</version>  
</dependency>

```

我们可以先把最基本的引入，如果不够肯定会报classnotfoundexception，到时候我们就知道缺少哪个了，老夫的原则是能少引入绝不多引入，原因一是怕冲突，二是文件大小和启动速度

(2). 和spring集成的配置文件activiti.cfg.xml

```

<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd  
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd">

<bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">  
<!&#8211; 连接数据的配置 &#8211;>  
<property name="jdbcDriver" value="com.mysql.jdbc.Driver"></property>  
<property name="jdbcUrl" value="jdbc:mysql://localhost:3306/itcast0711activiti?useUnicode=true&characterEncoding=utf8"></property>  
<property name="jdbcUsername" value="root"></property>  
<property name="jdbcPassword" value="root"></property>  
<!&#8211; 没有表创建表 &#8211;>  
<property name="databaseSchemaUpdate" value="true"></property>  
</bean>

</beans>

```

这个集成文件简单吧？对，就是这么简单，至于spring等其他的配置文件啊，log的配置文件就不多说了，接下来我们要开始Activiti5的实战：开始写代码。

二. Activiti5实战

Activiti5实战，所以第一步肯定是画图，但装好了环境之后，其实上面那篇文章是有怎么画图的，所以画图这个就先讲怎么花了，大家可以画一个最简单的练手，本文作为一个入门教程，也不会涉及到那些复杂的图，所以第一步，咱直接开始启动流程定义。

因为Activiti5所有的操作都和ProcessEngine相关，所以所有的操作都和ProcessEngine相关，我们就先获取这个对象，当做第0步吧：

```

ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();

```

1. 部署流程定义

部署流程定义，有两种，1. 从zip部署，也就是把我们的流程图压缩成zip，然后上传到项目的根目录，部署流程。

(1). 从zip部署

```

/*\*部署流程定义（从zip）\*/  
@Test  
public void deploymentProcessDefinition_zip(){  
InputStream in = this.getClass().getClassLoader().getResourceAsStream("diagrams/helloworld.zip");  
ZipInputStream zipInputStream = new ZipInputStream(in);  
Deployment deployment = processEngine.getRepositoryService()//与流程定义和部署对象相关的Service  
.createDeployment()//创建一个部署对象  
.name("流程定义")//添加部署的名称  
.addZipInputStream(zipInputStream)//指定zip格式的文件完成部署  
.deploy();//完成部署  
System.out.println("部署ID："+deployment.getId());//  
System.out.println("部署名称："+deployment.getName());//  
}

```

(2). 从资源文件

```

/*\*部署流程定义（从classpath）\*/  
@Test  
public void deploymentProcessDefinition_classpath(){  
Deployment deployment = processEngine.getRepositoryService()//与流程定义和部署对象相关的Service  
.createDeployment()//创建一个部署对象  
.name("流程定义")//添加部署的名称  
.addClasspathResource("diagrams/helloworld.bpmn")//从classpath的资源中加载，一次只能加载一个文件  
.addClasspathResource("diagrams/helloworld.png")//从classpath的资源中加载，一次只能加载一个文件  
.deploy();//完成部署  
System.out.println("部署ID："+deployment.getId());//  
System.out.println("部署名称："+deployment.getName());//  
}

```

2. 启动流程实例

当流程实例部署完成之后，肯定是开始启动流程了，下面我们就开始启动流程

```

/*\*启动流程实例\*/  
@Test  
public void startProcessInstance(){  
//流程定义的key  
String processDefinitionKey = "helloworld";  
ProcessInstance pi = processEngine.getRuntimeService()//与正在执行的流程实例和执行对象相关的Service  
.startProcessInstanceByKey(processDefinitionKey);//使用流程定义的key启动流程实例，key对应helloworld.bpmn文件中id的属性值，使用key值启动，默认是按照最新版本的流程定义启动  
System.out.println("流程实例ID:"+pi.getId());//流程实例ID 101  
System.out.println("流程定义ID:"+pi.getProcessDefinitionId());//流程定义ID helloworld:1:4  
}

```

其中helloworld就是我们画的流程图的名字，启动流程实例之后，肯定是要查询我的任务了，所以接下来查询的任务

3. 查询我的任务

查询我的任务，分好几种，一种是我们在画图的时候，直接把这个任务就分配到某个人，另一种是分配到一个组，就是只要这个组有这个权限，那么都可以获取这个任务，还有一个是我们画图的时候什么都不指定，到流程执行到这个的时候动态指定，后两个先不说，我们先说第一个

```

/*\*查询当前人的个人任务\*/  
@Test  
public void findMyPersonalTask(){  
String assignee = "王五";  
List<Task> list = processEngine.getTaskService()//与正在执行的任务管理相关的Service  
.createTaskQuery()//创建任务查询对象  
/*\*查询条件（where部分）\*/  
.taskAssignee(assignee)//指定个人任务查询，指定办理人  
// .taskCandidateUser(candidateUser)//组任务的办理人查询  
// .processDefinitionId(processDefinitionId)//使用流程定义ID查询  
// .processInstanceId(processInstanceId)//使用流程实例ID查询  
// .executionId(executionId)//使用执行对象ID查询  
/*\*排序\*/  
.orderByTaskCreateTime().asc()//使用创建时间的升序排列  
/*\*返回结果集\*/  
// .singleResult()//返回惟一结果集  
// .count()//返回结果集的数量  
// .listPage(firstResult, maxResults);//分页查询  
.list();//返回列表  
if(list!=null && list.size()>0){  
for(Task task:list){  
System.out.println("任务ID:"+task.getId());  
System.out.println("任务名称:"+task.getName());  
System.out.println("任务的创建时间:"+task.getCreateTime());  
System.out.println("任务的办理人:"+task.getAssignee());  
System.out.println("流程实例ID："+task.getProcessInstanceId());  
System.out.println("执行对象ID:"+task.getExecutionId());  
System.out.println("流程定义ID:"+task.getProcessDefinitionId());  
System.out.println("########################################################");  
}  
}  
}

```

查询我的任务之后我们，肯定要认领任务，然后完成任务，所以接下来就是这一步

4. 认领和完成任务

```

/*\*完成我的任务\*/  
@Test  
public void completeMyPersonalTask(){  
//任务ID  
String taskId = "1202";  
processEngine.getTaskService()//与正在执行的任务管理相关的Service  
.complete(taskId);  
System.out.println("完成任务：任务ID："+taskId);  
}

```

完成了我们自己的任务之后，流程就会按照流程图标记的那样，往后走，那么我们怎么知道这个流程什么时候结束呢？下面我们就要查询流程的状态

5. 流程状态查询

```

/*\*查询流程状态（判断流程正在执行，还是结束）\*/  
@Test  
public void isProcessEnd(){  
String processInstanceId = "1001";  
ProcessInstance pi = processEngine.getRuntimeService()//表示正在执行的流程实例和执行对象  
.createProcessInstanceQuery()//创建流程实例查询  
.processInstanceId(processInstanceId)//使用流程实例ID查询  
.singleResult();  
if(pi==null){  
System.out.println("流程已经结束");  
}  
else{  
System.out.println("流程没有结束");  
}  
}

```

6. 删除流程定义

我们在部署启动了流程定义之后，某些流程可能会由于各种各样的原因，导致流程无效，那么这个时候如果我们想删除该流程实例，那么这么做

```

/*\*附加功能：删除流程定义（删除key相同的所有不同版本的流程定义）\*/  
@Test  
public void deleteProcessDefinitionByKey(){  
//流程定义的key  
String processDefinitionKey = "helloworld";  
//先使用流程定义的key查询流程定义，查询出所有的版本  
List<ProcessDefinition> list = processEngine.getRepositoryService()//  
.createProcessDefinitionQuery()//  
.processDefinitionKey(processDefinitionKey)//使用流程定义的key查询  
.list();  
//遍历，获取每个流程定义的部署ID  
if(list!=null && list.size()>0){  
for(ProcessDefinition pd:list){  
//获取部署ID  
String deploymentId = pd.getDeploymentId();  
processEngine.getRepositoryService()//  
.deleteDeployment(deploymentId, true);  
}  
}  
}

```

或者也可以这么删除

```

/*\*删除流程定义\*/  
@Test  
public void deleteProcessDefinition(){  
//使用部署ID，完成删除  
String deploymentId = "601";  
/**  
* 不带级联的删除  
* 只能删除没有启动的流程，如果流程启动，就会抛出异常  
*/  
// processEngine.getRepositoryService()//  
// .deleteDeployment(deploymentId);

/**  
* 级联删除  
* 不管流程是否启动，都能可以删除  
*/  
processEngine.getRepositoryService()//  
.deleteDeployment(deploymentId, true);  
System.out.println("删除成功！");  
}

```

7. 查询流程定义

在我们的正式系统中，每次肯定不会只有一个流程，我们想看看系统中有多少流程，可以这么做

```

/*\*查询流程定义\*/  
@Test  
public void findProcessDefinition(){  
List<ProcessDefinition> list = processEngine.getRepositoryService()//与流程定义和部署对象相关的Service  
.createProcessDefinitionQuery()//创建一个流程定义的查询  
/*\*指定查询条件,where条件\*/  
// .deploymentId(deploymentId)//使用部署对象ID查询  
// .processDefinitionId(processDefinitionId)//使用流程定义ID查询  
// .processDefinitionKey(processDefinitionKey)//使用流程定义的key查询  
// .processDefinitionNameLike(processDefinitionNameLike)//使用流程定义的名称模糊查询

/*\*排序\*/  
.orderByProcessDefinitionVersion().asc()//按照版本的升序排列  
// .orderByProcessDefinitionName().desc()//按照流程定义的名称降序排列

/*\*返回的结果集\*/  
.list();//返回一个集合列表，封装流程定义  
// .singleResult();//返回惟一结果集  
// .count();//返回结果集数量  
// .listPage(firstResult, maxResults);//分页查询  
if(list!=null && list.size()>0){  
for(ProcessDefinition pd:list){  
System.out.println("流程定义ID:"+pd.getId());//流程定义的key+版本+随机生成数  
System.out.println("流程定义的名称:"+pd.getName());//对应helloworld.bpmn文件中的name属性值  
System.out.println("流程定义的key:"+pd.getKey());//对应helloworld.bpmn文件中的id属性值  
System.out.println("流程定义的版本:"+pd.getVersion());//当流程定义的key值相同的相同下，版本升级，默认1  
System.out.println("资源名称bpmn文件:"+pd.getResourceName());  
System.out.println("资源名称png文件:"+pd.getDiagramResourceName());  
System.out.println("部署对象ID："+pd.getDeploymentId());  
System.out.println("#########################################################");  
}  
}  
}

```

好了，这就是我们的上，介绍了一些最基本的功能，其实写完之后发现，应该写一下画图的，因为代码就是根据画图来的，所以画图可以说是Activiti5最最重要的基本功，不过算了，这个就留给大家自学吧，在接下来的下篇中，我会介绍一些算是更高级也是非常经常用到的一些功能的。