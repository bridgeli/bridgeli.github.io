---
title: POI解析Excel示例
author: Bridge Li
type: post
date: 2016-03-13T14:13:56+00:00

duoshuo_thread_id:
  - 6.2615402327688E+18
categories:
  - Java
tags:
  - Excel
  - Jxl
  - POI

---
在Java的世界里，对于解析Excel，目前市场上有两个不错的框架，一个是jxl另一个是poi，之前老夫曾对jxl可以说是倍加赞赏（当时老夫还为了它而写了一篇文章，详见[这里][1]），因为一直认为它虽然有bug，虽然兼容性不好，但是它简单易用啊，只要自己够仔细认真就能避开这些坑，但是从这周起，老夫决定jxl一生黑，因为随着时间的推移，现在Excel的版本越来越新，而jxl只支持2003之前的版本，可以说解析起来异常麻烦，而poi有Apache做保证，表现越来越好，使用起来其实也不是很复杂，所以老夫决定之后再次遇到解析Excel的只用poi。  
下面是老夫写的一个解析Excel的一个工具类，希望对大家有所帮助。

1. 解析Excel所需的类库的maven依赖

```

<dependency>  
<groupId>org.apache.poi</groupId>  
<artifactId>poi</artifactId>  
<version>3.14</version>  
</dependency>

<dependency>  
<groupId>org.apache.poi</groupId>  
<artifactId>poi-ooxml</artifactId>  
<version>3.14</version>  
</dependency>

<dependency>  
<groupId>org.apache.commons</groupId>  
<artifactId>commons-io</artifactId>  
<version>1.3.2</version>  
</dependency>

```

2. 解析的具体方法

```

package cn.bridgeli.demo;

import java.io.FileInputStream;  
import java.util.Date;  
import java.util.HashMap;  
import java.util.LinkedList;  
import java.util.List;  
import java.util.Map;

import org.apache.commons.io.FilenameUtils;  
import org.apache.poi.hssf.usermodel.HSSFWorkbook;  
import org.apache.poi.ss.usermodel.Cell;  
import org.apache.poi.ss.usermodel.DataFormatter;  
import org.apache.poi.ss.usermodel.DateUtil;  
import org.apache.poi.ss.usermodel.Row;  
import org.apache.poi.ss.usermodel.Sheet;  
import org.apache.poi.ss.usermodel.Workbook;  
import org.apache.poi.xssf.usermodel.XSSFWorkbook;  
import org.junit.Test;

public class ExcelReader {

protected static final String dateTimeFmtPattern = "yyyy-MM-dd HH:mm:ss";

protected static final String dateFmtPattern = "yyyy-MM-dd";

protected static final DataFormatter formatter = new DataFormatter();

@Test  
public void testReader() throws Exception {  
List<Map<String, String>> list = readExcel("E:/test1.xls");  
List<Map<String, String>> list2 = readExcel("E:/test1.xlsx");  
}

/**  
* 读取excel文件（同时支持2003和2007格式）  
*  
* @param fileName  
* 文件名，绝对路径  
* @return list中的map的key是列的序号  
* @throws Exception  
* io异常等  
*/  
public static List<Map<String, String>> readExcel(String fileName) throws Exception {  
FileInputStream fis = null;  
Workbook wb = null;  
List<Map<String, String>> list = null;  
try {  
String extension = FilenameUtils.getExtension(fileName);

fis = new FileInputStream(fileName);  
list = read(fis, extension);

return list;

} finally {  
if (null != wb) {  
wb.close();  
}

if (null != fis) {  
fis.close();  
}  
}

}

/**  
* 读取excel文件（同时支持2003和2007格式）  
*  
* @param fis  
* 文件输入流  
* @param extension  
* 文件名扩展名: xls 或 xlsx 不区分大小写  
* @return list中的map的key是列的序号  
* @throws Exception  
* io异常等  
*/  
public static List<Map<String, String>> read(FileInputStream fis, String extension) throws Exception {

Workbook wb = null;  
List<Map<String, String>> list = null;  
try {

if ("xls".equalsIgnoreCase(extension)) {  
wb = new HSSFWorkbook(fis);  
} else if ("xlsx".equalsIgnoreCase(extension)) {  
wb = new XSSFWorkbook(fis);  
} else {  
throw new Exception("file is not office excel");  
}

list = readWorkbook(wb);

return list;

} finally {  
if (null != wb) {  
wb.close();  
}  
}

}

protected static List<Map<String, String>> readWorkbook(Workbook wb) throws Exception {  
List<Map<String, String>> list = new LinkedList<Map<String, String>>();

for (int k = 0; k < wb.getNumberOfSheets(); k++) {  
Sheet sheet = wb.getSheetAt(k);  
int rows = sheet.getPhysicalNumberOfRows();

for (int r = 0; r < rows; r++) {  
Row row = sheet.getRow(r);  
if (row == null) {  
continue;  
}  
Map<String, String> map = new HashMap<String, String>();  
int cells = row.getPhysicalNumberOfCells();

for (int c = 0; c < cells; c++) {  
Cell cell = row.getCell(c);  
if (cell == null) {  
continue;  
}  
String value = getCellValue(cell);  
map.put(String.valueOf(cell.getColumnIndex() + 1), value);  
}  
list.add(map);  
}

}

return list;  
}

protected static String getCellValue(Cell cell) {  
String value = null;

switch (cell.getCellType()) {  
case Cell.CELL_TYPE_FORMULA: // 公式  
case Cell.CELL_TYPE_NUMERIC: // 数字

double doubleVal = cell.getNumericCellValue();  
short format = cell.getCellStyle().getDataFormat();  
String formatString = cell.getCellStyle().getDataFormatString();

if (format == 14 || format == 31 || format == 57 || format == 58 || (format >= 176 && format <= 183)) {  
// 日期  
Date date = DateUtil.getJavaDate(doubleVal);  
value = formatDate(date, dateFmtPattern);  
} else if (format == 20 || format == 32 || (format >= 184 && format <= 187)) {  
// 时间  
Date date = DateUtil.getJavaDate(doubleVal);  
value = formatDate(date, "HH:mm");  
} else {  
value = String.valueOf(doubleVal);  
}

break;  
case Cell.CELL_TYPE_STRING: // 字符串  
value = cell.getStringCellValue();

break;  
case Cell.CELL_TYPE_BLANK: // 空白  
value = "";  
break;  
case Cell.CELL_TYPE_BOOLEAN: // Boolean  
value = String.valueOf(cell.getBooleanCellValue());  
break;  
case Cell.CELL_TYPE_ERROR: // Error，返回错误码  
value = String.valueOf(cell.getErrorCellValue());  
break;  
default:  
value = "";  
break;  
}  
return value;  
}

@SuppressWarnings("deprecation")  
private static String formatDate(Date d, String sdf) {  
String value = null;

if (d.getSeconds() == 0 && d.getMinutes() == 0 && d.getHours() == 0) {  
// value = DateTimeUtil.getFormatedDate(d, dateFmtPattern);  
} else {  
// value = DateTimeUtil.getFormatedDate(d, sdf);

}

return value;  
}

}

```

对于这些第三方工具类的框架来说，老夫一直认为我们没有必要每次都自己去一步一步的写，只要写一次就够了，所以本文就是老夫的一个笔记而已，希望做到无论是老夫还是渎职今后只要需要解析Excel的时候，找到这里，把这里的方法copy出去，改吧改吧就能用了，另外本文也只牵涉到对Excel的解析而已，并没有生成的部分，一方面我在工作中解析多余生成，另一方面我相信大家只要会解析生成也一定不是大问题，网上资料这么多，所以就留给读者自己去探索了

 [1]: https://www.bridgeli.cn/archives/50 "JXL解析Excel常用方法"