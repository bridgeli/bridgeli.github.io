---
title: Java GC之常见监控与分析命令总结（上）
author: Bridge Li
type: post
date: 2017-03-19T13:36:26+00:00

categories:
  - Java
tags:
  - GC
  - 性能调优
  - 监控

---
[上一篇文章][1]简单写了几种常见的垃圾收集器的参数设置，设置参数的时候离不开对对系统进行监控和分析，所以总结一下监控和分析的常见命令。

1. jps：JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程

命令格式：

```

jps \[options\] \[hostid\]

```

hostid为RMI注册表中注册的主机名，其他常用参数如下：  
-q：只输出LVMID，省略主类的名称  
-m：输出虚拟机进程启动的时候传递给主类main()方法的参数  
-l：输出主类的全名，如果进程执行的是jar包，输出jar路径  
-v：输出虚拟机进程启动时JVM参数

命令执行样例：

```

jps -l

```

2. jstat：JVM Statistics Monitoring Tool，用于收集Hotspot虚拟机各方面的运行数据

命令格式：

```

jstat \[option vmid [interval[s|ms\] \[count\]]]

```

对于命令格式中的VMID和LVMID，如过是本地虚拟机进程，VMID和LVMID是一致的，如果是远程虚拟机，那VMID的格式应当是：

```

\[protocol:\] \[//\] lvmid[@hostname[:port]/servername]

```

interval和count代表查询的间隔和次数，如果省略这两个参数，说明只查一次，其他常用参数：

-class：监视装载类、卸载类、总空间以及类装载所耗费的时间  
-gc：监视java堆状况，包括eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计信息  
-gccapacity：监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到最大、最小空间  
-gcutil：监视内容与-gc基本相同，但输出主要关注已使用控件占总空间的百分比  
-gccause：与-gcutil功能一样，但是会额外输出导致上一次gc产生的原因  
-gcnew：监视新生代GC情况  
-gcnewcapacity：监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间  
-gcold：监视老年代GC情况  
-gcoldcapacity：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间  
-gcpermcapacity：输出永久代使用到的最大、最小空间  
-compiler：输出JIT编译过的方法、耗时等信息  
-printcompilation：输出已经被JIT编译过的方法

命令执行样例：

```

jstat -gcutil 2764 1000

```

3. jinfo：Configuration Info for Java，显示虚拟机的配置信息

使用jps命令的-v参数可以查看虚拟机启动时显示指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料以外，就得使用jinfo的-flag选项，命令格式：

```

jinfo [option] pid

```

执行样例：查询CMSInitiatingOccupancyFraction参数值

```

jinfo -flag CMSInitiatingOccupancyFraction 2764

```

4. jmap：Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）

命令格式：

```

jmap [option] vmid

```

常用参数：

-dump：生成java堆转储快照。格式为： -dump:[live,]format=b,file=,其中live子参数说明是否只dump出存活的对象  
-finalizerinfo：显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效  
-heap：显示java堆详细信息，如使用哪种收集器、参数配置、分代情况等，在Linux/Solaris平台下有效  
-jisto：显示堆中对象统计信息，包含类、实例对象、合集容量  
-permstat：以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效  
-F：当虚拟机进程对-dump选项没有相应时。可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效

命令执行样例：

```

jmap -dump:live,format=b,file=heap.bin 2764

```

5. jhat：JVM Heap Dump Brower，用于分析headdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果

命令格式：

```

jhat heap.bin

```

屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost:7000就可以看到分析的结果了。分析结果默认是以包围单位进行分组显示，分析内存泄漏问题主要会使用到其中的“Heap Histogram”与OQL标签的功能。前者可以找到内存中总容量最大的对象。后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计

需要说明的是，除非没有其他的工具，一般不要使用这个命令分析dump文件，原因有二，1. 一般不会在部署应用的服务器上直接分析dump文件，因为分析是一个耗时和消耗硬件的过程；2. 这个命令过于简陋，和VisualVM、Eclipse Memory Analyzer等工具差远了

6. jstack：Stack Trace for Java，显示虚拟机的线程快照

jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致长时间等待等

命令格式：

```

jstack [option] vmid

```

常用参数：

-F：当正常输出的请求不被响应时，强制输出线程堆栈  
-l：除堆栈外，显示关于锁的附加信息  
-m：如果调用到本地方法的话，可以显示c/c++的堆栈

JDK 1.5 Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有的线程的StackTraceElement对象，使用这个方法可以通过简单的几行代码就完成jstack 的大部分功能，在实际项目中可以用这个管理员界面，随时通过浏览器查看线程堆栈，参考代码如下：

```

<%@ page import="java.util.Map" %>  
<body>  
<pre>  
<%  
for(Map.Entry<Thread, StackTraceElement[]> stackTrace : Thread.getAllStackTraces().entrySet()){  
Thread thread = (Thread)stackTrace.getKey();  
StackTraceElement[] stack = ( StackTraceElement[])stackTrace.getValue();

if(thread.equals(Thread.currentThread()))  
continue;

out.print("\n 线程:" + thread.getName() + "\n");  
for(StackTraceElement element : stack){  
out.print("\t" + element + "\n");  
}  
}

%>

</pre>  
</body>

```

参考资料：周志明《深入理解Java虚拟机》第二版第四章

 [1]: https://www.bridgeli.cn/archives/347 "Java GC之常见垃圾收集器参数总结"